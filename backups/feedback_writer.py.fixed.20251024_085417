#!/usr/bin/env python3
from __future__ import annotations

import json
import datetime
from pathlib import Path
from typing import Any, Dict, List

# === –ü–∞—Ä–∞–º–µ—Ç—Ä—ã/–ø—É—Ç–∏ ===
BASE = Path(__file__).resolve().parent
AF_DIR = BASE / "auto_feedback"
LESSONS_DIR = AF_DIR / "lessons"
ROLLING_PATH = LESSONS_DIR / "rolling.jsonl"
LESSONS_MD = LESSONS_DIR / "LESSONS_FOR_LLM.md"
AUTO_LESSONS = LESSONS_DIR / "Auto_Lessons.md"

# –ª–∏–º–∏—Ç—ã
ROLLING_MAX = 10000   # safety cap, —á—Ç–æ–±—ã —Ñ–∞–π–ª –±–µ—Å–∫–æ–Ω–µ—á–Ω–æ –Ω–µ —Ä–æ—Å
LESSONS_MAX = 200     # —Å–∫–æ–ª—å–∫–æ —Å—Ç—Ä–æ–∫ –≤–∫–ª—é—á–∞–µ–º –≤ Markdown

# —Å–æ–∑–¥–∞—ë–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏
AF_DIR.mkdir(exist_ok=True, parents=True)
LESSONS_DIR.mkdir(exist_ok=True, parents=True)

# –¥–æ–ø—É—Å—Ç–∏–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è
RESULT_OK = {"win", "loss", "breakeven", "skip"}
EXIT_OK   = {"tp1","tp2","sl","breakeven","no_entry","cancel","manual","timeout"}

def _month_dir(dt: datetime.datetime) -> Path:
    month = dt.strftime("%Y-%m")
    p = AF_DIR / month
    p.mkdir(parents=True, exist_ok=True)
    return p

def _safe_pair(pair: str) -> str:
    return (pair or "UNKNOWN").replace("/", "_").replace(" ", "")

def validate(d: Dict[str, Any]) -> Dict[str, Any]:
    """–ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è –∏ –Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è –ø–æ–ª–µ–π v1."""
    # –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è
    for k in ("pair","result"):
        if k not in d:
            raise ValueError(f"missing field: {k}")

    if d["result"] not in RESULT_OK:
        raise ValueError(f"result must be one of {sorted(RESULT_OK)}")

    if d.get("exit_reason"):
        if d["exit_reason"] not in EXIT_OK:
            raise ValueError(f"wrong exit_reason (allowed: {sorted(EXIT_OK)})")

    # –Ω–æ—Ä–º–∞–ª–∏–∑—É–µ–º datetime –≤ ISO, –µ—Å–ª–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç
    if not d.get("datetime"):
        d["datetime"] = datetime.datetime.now(datetime.timezone.utc).isoformat()

    return d

def _cap_rolling_if_needed() -> None:
    """–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä rolling.jsonl –≤ —Ä–∞–∑—É–º–Ω—ã—Ö –≥—Ä–∞–Ω–∏—Ü–∞—Ö."""
    try:
        text = ROLLING_PATH.read_text(encoding="utf-8")
    except Exception:
        return
    lines = [ln for ln in text.splitlines() if ln.strip()]
    if len(lines) <= ROLLING_MAX:
        return
    # –æ—Å—Ç–∞–≤–ª—è–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ ROLLING_MAX —Å—Ç—Ä–æ–∫
    ROLLING_PATH.write_text("\n".join(lines[-ROLLING_MAX:]) + "\n", encoding="utf-8")

def rebuild_lessons_md() -> int:
    """
    –°–±–æ—Ä–∫–∞ –∞–≤—Ç–æ-—É—Ä–æ–∫–æ–≤:
    - —á–∏—Ç–∞–µ—Ç auto_feedback/lessons/rolling.jsonl (feedback-—Å–Ω–∏–ø–ø–µ—Ç—ã)
    - —Ä–µ–Ω–¥–µ—Ä–∏—Ç –∫—Ä–∞—Ç–∫–∏–µ —Å—Ç—Ä–æ–∫–∏
    - –î–û–ë–ê–í–õ–Ø–ï–¢ –≤ –∫–æ–Ω–µ—Ü AUTO-–±–ª–æ–∫ (Auto_Lessons.md), –µ—Å–ª–∏ –æ–Ω —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —á–∏—Å–ª–æ feedback-—ç–ª–µ–º–µ–Ω—Ç–æ–≤ (–±–µ–∑ AUTO-–±–ª–æ–∫–∞).
    """
    items: List[str] = []
    if ROLLING_PATH.exists():
        for ln in ROLLING_PATH.read_text(encoding="utf-8").splitlines():
            ln = ln.strip()
            if not ln:
                continue
            try:
                d = json.loads(ln)
            except Exception:
                continue

            dt     = d.get("datetime") or d.get("ts") or ""
            pair   = d.get("pair", "")
            res    = d.get("result", "")
            issues = d.get("issues") or []
            fixes  = d.get("fixes")  or []
            if not isinstance(issues, list): issues = []
            if not isinstance(fixes, list):  fixes  = []
            issues_str = ", ".join(issues) if issues else "none"
            fixes_str  = ", ".join(fixes)  if fixes  else "none"

            note = ""
            pnl = d.get("pnl")
            if isinstance(pnl, dict):
                note = pnl.get("note") or ""
            if not note:
                note = d.get("comment", "") or "‚Äî"

            items.append(f"- {dt} ‚Ä¢ {pair} ‚Ä¢ result={res}; issues=[{issues_str}]; fixes=[{fixes_str}]; note: {note}")

    # –æ–≥—Ä–∞–Ω–∏—á–∏–º —Ö–≤–æ—Å—Ç–æ–º, —á—Ç–æ–±—ã –ø—Ä–æ–º–ø—Ç –Ω–µ —Ä–∞–∑–¥—É–≤–∞–ª—Å—è
    tail = items[-min(len(items), LESSONS_MAX):]
    header = "# [LESSONS]\n" \
             "–£—á–∏—Ç—ã–≤–∞–π –ø–æ–≤—Ç–æ—Ä—è—é—â–∏–µ—Å—è –æ—à–∏–±–∫–∏ –∏ –ø—Ä–∏–Ω—è—Ç—ã–µ —Ñ–∏–∫—Å—ã –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Å–∏–≥–Ω–∞–ª–∞. " \
             "–ù–∏–∂–µ –ø–æ—Å–ª–µ–¥–Ω–∏–µ —Å–ª—É—á–∞–∏ (—Å–≤–µ–∂–∏–µ –≤–Ω–∏–∑—É):\n\n"
    text = header + "\n".join(tail) + "\n"

    # –ø—Ä–∏–∫–ª–µ–∏–≤–∞–µ–º AUTO (–µ—Å–ª–∏ –µ—Å—Ç—å)
    if AUTO_LESSONS.exists():
        auto_txt = AUTO_LESSONS.read_text(encoding="utf-8").strip()
        if auto_txt:
            text += "\n" + auto_txt + "\n"

    LESSONS_MD.write_text(text, encoding="utf-8")
    return len(items)

def save_feedback(data: Dict[str, Any]) -> str:
    d = validate(dict(data))  # –∫–æ–ø–∏—è –∏ –≤–∞–ª–∏–¥–∞—Ü–∏—è

    # –≤—ã—á–∏—Å–ª—è–µ–º –∏–º—è —Ñ–∞–π–ª–∞
    now = datetime.datetime.now(datetime.timezone.utc)
    monthdir = _month_dir(now)
    pair = _safe_pair(d.get("pair"))
    sid = (d.get("signal_id") or now.strftime("%Y%m%d_%H%M%S"))
    json_path = monthdir / f"feedback_{pair}_{sid}.json"

    # —Å–æ—Ö—Ä–∞–Ω—è–µ–º —Å–∞–º —Å–Ω–∏–ø–ø–µ—Ç (–∫—Ä–∞—Å–∏–≤–æ)
    json_path.write_text(json.dumps(d, ensure_ascii=False, indent=2), encoding="utf-8")

    # –¥–æ–±–∞–≤–ª—è–µ–º –≤ rolling.jsonl (–æ–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–æ–π)
    with ROLLING_PATH.open("a", encoding="utf-8") as f:
        f.write(json.dumps(d, ensure_ascii=False) + "\n")

    # –æ–≥—Ä–∞–Ω–∏—á–∏–º —Ä–∞–∑–º–µ—Ä rolling –Ω–∞ –≤—Å—è–∫–∏–π
    _cap_rolling_if_needed()

    # –ø–µ—Ä–µ—Å–æ–±–µ—Ä—ë–º LESSONS_FOR_LLM.md
    n = rebuild_lessons_md()

    print(f"‚úÖ Feedback saved: {json_path}")
    print(f"üîÅ LESSONS rebuilt: {LESSONS_MD} ({n} items)")
    return str(json_path)

if __name__ == "__main__":
    import sys
    try:
        if not sys.stdin.isatty():
            raw = sys.stdin.read()
            data = json.loads(raw)
        else:
            if len(sys.argv) < 2:
                raise SystemExit("Usage: feedback_writer.py < file.json")
            with open(sys.argv[1], "r", encoding="utf-8") as fh:
                data = json.load(fh)
        save_feedback(data)
    except Exception as e:
        print(f"ERROR: {e}")
        sys.exit(1)
