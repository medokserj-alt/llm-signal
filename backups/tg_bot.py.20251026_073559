#!/usr/bin/env python3
import os, time, subprocess, pathlib, re, html as htmllib, json
from datetime import datetime
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.constants import ParseMode
from telegram.ext import Application, CommandHandler, CallbackQueryHandler, ContextTypes
from dotenv import load_dotenv
# ===== –±–∞–∑–æ–≤–∞—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è =====
BASE = pathlib.Path(__file__).resolve().parent
load_dotenv(BASE/".env.tg")

BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
CHANNEL   = os.getenv("TELEGRAM_TARGET_CHANNEL")

def parse_allowed_ids() -> list[int]:
    ids = []
    raw_multi = os.getenv("TELEGRAM_ALLOWED_USER_IDS", "")
    raw_legacy = os.getenv("TELEGRAM_ALLOWED_USER_ID", "")
    for raw in (raw_multi, raw_legacy):
        for x in raw.replace(";", ",").split(","):
            x = x.strip()
            if x and (x.lstrip("-").isdigit()):
                try:
                    ids.append(int(x))
                except:  # noqa
                    pass
    # —É–±–∏—Ä–∞–µ–º –¥—É–±–ª–∏
    return list(dict.fromkeys(ids))

ALLOWED_UIDS = parse_allowed_ids()

def latest(pattern: str):
    files = list(BASE.glob(pattern))
    return max(files, key=lambda p: p.stat().st_mtime) if files else None

def html_file_to_tg_text(p: pathlib.Path, max_len=4000):
    s = p.read_text(encoding="utf-8")
    m = re.search(r'<body[^>]*>(.*?)</body>', s, flags=re.S|re.I)
    s = m.group(1) if m else s
    s = re.sub(r'<\s*(strong)\s*>', '<b>', s, flags=re.I)
    s = re.sub(r'<\s*/\s*(strong)\s*>', '</b>', s, flags=re.I)
    s = re.sub(r'<\s*(em)\s*>', '<i>', s, flags=re.I)
    s = re.sub(r'<\s*/\s*(em)\s*>', '</i>', s, flags=re.I)
    s = re.sub(r'<\s*br\s*/?>', '\n', s, flags=re.I)
    s = re.sub(r'</\s*p\s*>', '\n\n', s, flags=re.I)
    s = re.sub(r'<\s*p[^>]*>', '', s, flags=re.I)
    s = re.sub(r'<[^>]+>', '', s)
    s = htmllib.unescape(s)
    s = re.sub(r'[ \t]+\n', '\n', s).strip()
    chunks = []
    while s:
        chunks.append(s[:max_len])
        s = s[max_len:]
    return chunks

def md_file_to_chunks(p: pathlib.Path, max_len=4000):
    s = p.read_text(encoding="utf-8").strip()
    chunks = []
    while s:
        chunks.append(s[:max_len])
        s = s[max_len:]
    return chunks

def is_allowed(uid: int) -> bool:
    # –µ—Å–ª–∏ —Å–ø–∏—Å–æ–∫ –ø—É—Å—Ç ‚Äî –±–ª–æ–∫–∏—Ä—É–µ–º –≤—Å–µ—Ö (—è–≤–Ω–∞—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å)
    return (uid in ALLOWED_UIDS) if ALLOWED_UIDS else False

# ===== –∏–º–ø–æ—Ä—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Å–Ω–∏–ø–ø–µ—Ç–æ–≤ =====
try:
    from feedback_writer import save_feedback  # –æ–∂–∏–¥–∞–µ—Ç—Å—è —Ñ–∞–π–ª feedback_writer.py –≤ —Ç–æ–º –∂–µ –∫–∞—Ç–∞–ª–æ–≥–µ
    FEEDBACK_AVAILABLE = True
except Exception as _e:
    save_feedback = None
    FEEDBACK_AVAILABLE = False

# ===== —É—Ç–∏–ª–∏—Ç–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ JSON –∏–∑ —Ç–µ–∫—Å—Ç–∞ –∫–æ–º–∞–Ω–¥—ã =====
def extract_json_from_text(text: str) -> str | None:
    """
    –ü—Ä–∏–Ω–∏–º–∞–µ—Ç —Ç–µ–∫—Å—Ç —Å–æ–æ–±—â–µ–Ω–∏—è (–º–æ–∂–µ—Ç –±—ã—Ç—å: /feedback {...} –∏–ª–∏ —Å —Ç—Ä–æ–π–Ω—ã–º–∏ –∫–∞–≤—ã—á–∫–∞–º–∏/–±—ç–∫—Ç–∏–∫–∞–º–∏).
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —á–∏—Å—Ç—ã–π JSON-—Å—Ç—Ä–æ–∫—É –∏–ª–∏ None.
    """
    if not text:
        return None
    # —É–±–∏—Ä–∞–µ–º –ø—Ä–µ—Ñ–∏–∫—Å "/feedback"
    text = re.sub(r'^\s*/feedback\s*', '', text, flags=re.I).strip()
    if not text:
        return None

    # —Å—Ä–µ–∑–∞–µ–º Markdown-–∫–æ–¥–±–ª–æ–∫–∏ ```json ... ```
    fence = re.search(r"```(?:json)?\s*(.+?)```", text, flags=re.S|re.I)
    if fence:
        return fence.group(1).strip()

    # —Å—Ä–µ–∑–∞–µ–º –≤–æ–∑–º–æ–∂–Ω—ã–µ –æ–¥–∏–Ω–∞—Ä–Ω—ã–µ –±—ç–∫—Ç–∏–∫–∏ `...`
    inline = re.search(r"`\s*(\{.+\})\s*`", text, flags=re.S)
    if inline:
        return inline.group(1).strip()

    # –∏–ª–∏ —ç—Ç–æ —É–∂–µ —á–∏—Å—Ç—ã–π JSON
    if text.lstrip().startswith("{") and text.rstrip().endswith("}"):
        return text.strip()

    return None

# ===== handlers =====
async def whoami(update: Update, context: ContextTypes.DEFAULT_TYPE):
    uid = update.effective_user.id if update.effective_user else None
    await update.message.reply_text(
        "whoami\n"
        f"- your id: {uid}\n"
        f"- allowed: {ALLOWED_UIDS}\n"
        f"- channel: {CHANNEL}"
    )

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    uid = update.effective_user.id if update.effective_user else 0
    if not is_allowed(uid):
        await update.message.reply_text("–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â—ë–Ω.")
        return
    kb = [
        [InlineKeyboardButton("üîç FULL –∞–Ω–∞–ª–∏–∑ (–ø—É–ª)", callback_data="run_full")],
        [InlineKeyboardButton("üìù –î–æ–±–∞–≤–∏—Ç—å feedback", callback_data="feedback_howto")]
    ]
    await update.message.reply_text("–í—ã–±–µ—Ä–∏ –¥–µ–π—Å—Ç–≤–∏–µ:", reply_markup=InlineKeyboardMarkup(kb))

async def run_full_cb(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    uid = update.effective_user.id if update.effective_user else 0
    if not is_allowed(uid):
        await query.answer("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞", show_alert=True); return
    await query.answer()
    msg = await query.message.reply_text("–ó–∞–ø—É—Å–∫–∞—é FULL –∞–Ω–∞–ª–∏–∑‚Ä¶ —ç—Ç–æ –∑–∞–π–º—ë—Ç –Ω–µ–º–Ω–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏.")

    t0 = time.time()
    proc = subprocess.run(
        ["bash","-lc","cd ~/llm-signal && ./signal full"],
        capture_output=True, text=True, timeout=900
    )
    t1 = time.time()

    tail = "\n".join(proc.stdout.strip().splitlines()[-20:])
    safe_tail = htmllib.escape(tail)
    await msg.edit_text(f"–ì–æ—Ç–æ–≤–æ –∑–∞ {t1-t0:.1f}s\n<b>–•–≤–æ—Å—Ç –ª–æ–≥–∞:</b>\n<pre>{safe_tail}</pre>",
                        parse_mode=ParseMode.HTML)

    analysis = latest("analysis_*.md")
    sig_html = latest("signal_*.html")

    if analysis:
        header = f"üìù LLM Full –∞–Ω–∞–ª–∏–∑ ‚Ä¢ {datetime.now().strftime('%d.%m.%Y %H:%M')}\n\n"
        parts = md_file_to_chunks(analysis)
        await context.bot.send_message(chat_id=CHANNEL, text=header + parts[0])
        for chunk in parts[1:]:
            await context.bot.send_message(chat_id=CHANNEL, text=chunk)

    if sig_html:
        parts = html_file_to_tg_text(sig_html)
        parts[0] = "üì£ –°–∏–≥–Ω–∞–ª\n\n" + parts[0]
        await context.bot.send_message(chat_id=CHANNEL, text=parts[0], parse_mode=ParseMode.HTML)
        for chunk in parts[1:]:
            await context.bot.send_message(chat_id=CHANNEL, text=chunk, parse_mode=ParseMode.HTML)

async def feedback_howto_cb(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—é –∫–∞–∫ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–Ω–∏–ø–ø–µ—Ç."""
    query = update.callback_query
    uid = update.effective_user.id if update.effective_user else 0
    if not is_allowed(uid):
        await query.answer("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞", show_alert=True); return
    await query.answer()
    if not FEEDBACK_AVAILABLE:
        await query.message.reply_text("‚ùå feedback_writer.py –Ω–µ –Ω–∞–π–¥–µ–Ω. –î–æ–±–∞–≤—å —Ñ–∞–π–ª –∏ –ø–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏ –±–æ—Ç–∞.")
        return

    example = (
        "/feedback ```json\n"
        "{\n"
        '  "signal_id": "20251021_152045",\n'
        '  "pair": "LINK/USDT",\n'
        '  "side": "long",\n'
        '  "result": "win",\n'
        '  "exit_reason": "tp2",\n'
        '  "issues": [],\n'
        '  "fixes": [],\n'
        '  "comment": "–∏–¥–µ–∞–ª—å–Ω—ã–π –≤—Ö–æ–¥ –ø–æ—Å–ª–µ EMA20",\n'
        '  "reviewer": "Anya"\n'
        "}\n"
        "```"
    )
    await query.message.reply_text(
        "–û–∫, –ø—Ä–∏—à–ª–∏ JSON —Å–Ω–∏–ø–ø–µ—Ç –∫–æ–º–∞–Ω–¥–æ–π /feedback.\n\n"
        "–ü—Ä–∏–º–µ—Ä:\n" + example
    )

async def feedback_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ü—Ä–∏–Ω–∏–º–∞–µ–º JSON, —Å–æ—Ö—Ä–∞–Ω—è–µ–º —á–µ—Ä–µ–∑ feedback_writer.save_feedback."""
    uid = update.effective_user.id if update.effective_user else 0
    if not is_allowed(uid):
        await update.message.reply_text("–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â—ë–Ω.")
        return
    if not FEEDBACK_AVAILABLE:
        await update.message.reply_text("‚ùå feedback_writer.py –Ω–µ –Ω–∞–π–¥–µ–Ω. –î–æ–±–∞–≤—å —Ñ–∞–π–ª –∏ –ø–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏ –±–æ—Ç–∞.")
        return

    raw = update.message.text or ""
    payload = extract_json_from_text(raw)
    if not payload:
        await update.message.reply_text(
            "–ù–µ –Ω–∞—à—ë–ª JSON –≤ —Å–æ–æ–±—â–µ–Ω–∏–∏.\n"
            "–ü—Ä–∏—à–ª–∏ –≤ —Ñ–æ—Ä–º–∞—Ç–µ:\n"
            "/feedback {\"signal_id\":\"...\",\"pair\":\"LINK/USDT\",...}\n"
            "–∏–ª–∏ –≤ –±–ª–æ–∫–µ ```json ... ```"
        )
        return

    try:
        data = json.loads(payload)
    except Exception as e:
        await update.message.reply_text(f"‚ùå –û—à–∏–±–∫–∞ JSON: {e}")
        return

    # –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –∫–ª—é—á–µ–π (–º—è–≥–∫–∞—è)
    required = ["pair", "result"]
    missing = [k for k in required if k not in data]
    if missing:
        await update.message.reply_text(f"‚ùå –ù–µ —Ö–≤–∞—Ç–∞–µ—Ç –ø–æ–ª–µ–π: {', '.join(missing)}")
        return

    try:
        path_saved = save_feedback(data)  # –æ–∂–∏–¥–∞–Ω–∏–µ: —Ñ—É–Ω–∫—Ü–∏—è –≤–µ—Ä–Ω—ë—Ç –ø—É—Ç—å —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω–æ–≥–æ —Ñ–∞–π–ª–∞ –∏–ª–∏ None
    except TypeError:
        # –µ—Å–ª–∏ save_feedback –Ω–∏—á–µ–≥–æ –Ω–µ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç ‚Äî –ø—Ä–æ—Å—Ç–æ –≤—ã–∑–≤–∞–ª–∏
        save_feedback(data)
        path_saved = None
    except Exception as e:
        await update.message.reply_text(f"‚ùå –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è: {e}")
        return

    suffix = f"\nüìÅ {path_saved}" if path_saved else ""
    await update.message.reply_text("‚úÖ Feedback —Å–æ—Ö—Ä–∞–Ω—ë–Ω." + suffix)

# ===== main =====
def main():
    if not BOT_TOKEN or not CHANNEL:
        raise SystemExit("Set TELEGRAM_BOT_TOKEN and TELEGRAM_TARGET_CHANNEL in .env.tg")
    app = Application.builder().token(BOT_TOKEN).build()

    app.add_handler(CommandHandler("whoami", whoami))
    app.add_handler(CommandHandler("start", start))
    app.add_handler(CallbackQueryHandler(run_full_cb, pattern="^run_full$"))

    # feedback: –∫–Ω–æ–ø–∫–∞-–∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—è –∏ –∫–æ–º–∞–Ω–¥–∞ –¥–ª—è JSON
    app.add_handler(CallbackQueryHandler(feedback_howto_cb, pattern="^feedback_howto$"))
    app.add_handler(CommandHandler("feedback", feedback_cmd))

    app.run_polling(allowed_updates=Update.ALL_TYPES)

if __name__ == "__main__":
    main()
