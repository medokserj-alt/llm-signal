#!/usr/bin/env python3
import os, sys, json, argparse
from datetime import datetime
from zoneinfo import ZoneInfo
from dotenv import load_dotenv
from openai import OpenAI
import ccxt
import subprocess

# --- LESSONS loader (runtime, robust) ---
import pathlib as _pl

def _resolve_lessons_path():
    _env_path = os.getenv("LLM_LESSONS_FILE")
    if not _env_path:
        return None
    q = _pl.Path(_env_path)
    if not q.is_absolute():
        q = (_pl.Path(__file__).resolve().parent / q).resolve()
    return q

def load_lessons():
    """
    Возвращает (text, count, path_str):
    - text: готовый блок для промпта (включая заголовок "# [LESSONS]" и перевод строки), либо "".
    - count: число НЕпустых строк, не начинающихся с '#'.
    - path_str: строка с абсолютным путём (если известен), иначе "".
    """
    q = _resolve_lessons_path()
    if not q:
        return ("", 0, "")
    try:
        if not q.exists():
            return ("", 0, str(q))
        raw = q.read_text(encoding="utf-8")
    except Exception:
        return ("", 0, str(q))
    lines = [ln for ln in raw.splitlines() if ln.strip() and not ln.lstrip().startswith("#")]
    body = "\n".join(lines).strip()
    if not body:
        return ("", 0, str(q))
    text = "\n# [LESSONS]\n" + body + "\n"
    # --- Fallback: если в собранном LESSONS нет маркера AUTO, добавим Auto_Lessons.md ---
    try:
        if "AUTO_LESSONS" not in raw:
            from pathlib import Path as _P
            _ap = (_pl.Path(__file__).resolve().parent / "auto_feedback/lessons/Auto_Lessons.md").resolve()
            if _ap.exists():
                _auto = _ap.read_text(encoding="utf-8").strip()
                if _auto:
                    body2 = (body + "\n" + _auto).strip()
                    text  = "\n# [LESSONS]\n" + body2 + "\n"
                    lines = [ln for ln in body2.splitlines() if ln.strip() and not ln.lstrip().startswith("#")]
                    return (text, len(lines), str(q))
    except Exception:
        pass
        return (text, len(lines), str(q))
# ------------------------------------------
# ---------------- Helpers ----------------

def snapshot_from_status() -> str:
    """
    Возвращаем текст от ./status (или ./status --for-llm), без падений при ошибке.
    """
    try:
        cmd = 'cd ~/llm-signal && ./status --for-llm 2>/dev/null || ./status 2>/dev/null'
        res = subprocess.run(["bash","-lc",cmd], capture_output=True, text=True, timeout=30)
        return res.stdout.strip()
    except Exception:
        return ""

def read_file(path: str) -> str:
    with open(path, "r", encoding="utf-8") as f:
        return f.read().strip()

def current_msk() -> str:
    return datetime.now(ZoneInfo("Europe/Moscow")).strftime("%d.%m.%Y, %H:%M")

# ---- тикеры с last и 24h % (на всякий) ----

def _fetch_ticker(ex, sym):
    t = ex.fetch_ticker(sym)
    last = t.get("last")
    if last is None:
        bid, ask = t.get("bid"), t.get("ask")
        if bid and ask:
            last = (bid + ask) / 2
    change = t.get("percentage")  # 24h %
    return float(last) if last is not None else None, (float(change) if change is not None else None)

def get_pair_ticker(sym: str):
    bybit = ccxt.bybit(); binance = ccxt.binance()
    for ex in (bybit, binance):
        try:
            last, change = _fetch_ticker(ex, sym)
            if last is not None:
                return {"last": last, "change": change}
        except Exception:
            pass
    return {"last": None, "change": None}

def get_pool_snapshot() -> dict:
    with open("pool.json","r",encoding="utf-8") as f:
        pool = json.load(f)["pool"]
    out = {}
    for sym in pool:
        out[sym] = get_pair_ticker(sym)
    return out

# ----- NEWS helpers -----

def get_news_block(hours: int = 12) -> str:
    """
    Возвращает текстовый блок NEWS из news_snapshot.py (без падений при ошибке).
    """
    try:
        news_txt = subprocess.run(
            ["bash","-lc",f"cd ~/llm-signal && ./news_snapshot.py {hours}"],
            capture_output=True, text=True, timeout=30
        ).stdout.strip()
    except Exception:
        news_txt = ""
    if not news_txt:
        news_txt = "— новости недоступны"
    return (
        "\n==========================\n"
        "=== [NEWS] ===\n" + news_txt + "\n"
        "==========================\n"
    )

def build_news_focus(symbol: str, news_block: str) -> str:
    """
    Из общего NEWS блока вытаскиваем максимум 3 релевантных строки:
    - с упоминанием тикера (SOL, AAVE, LINK и т.д.) или названия проекта,
    - либо обще-рыночные (ETF, SEC, macro, liquidation).
    Возвращаем как маркированный список (или пустую строку).
    """
    symbol_root = symbol.split("/")[0].upper() if symbol else ""
    lines = [ln.strip("- ").strip() for ln in news_block.splitlines() if ln.strip().startswith("- ")]
    key = symbol_root
    picked = []
    for ln in lines:
        u = ln.upper()
        if (key and key in u) or any(k in u for k in ("ETF","SEC","FED","MACRO","INFLATION","LIQUIDATION","LIQUIDATIONS")):
            picked.append(ln)
        if len(picked) >= 3:
            break
    return "\n".join(picked)

# ---------------- Bootstrap ----------------

from pathlib import Path
BASE = Path(__file__).resolve().parent
load_dotenv(BASE/".env")
api_key = os.getenv("OPENAI_API_KEY")
if not api_key:
    print("ERROR: OPENAI_API_KEY not set (put it in .env)", file=sys.stderr)
    sys.exit(1)
client = OpenAI(api_key=api_key)

ap = argparse.ArgumentParser()
ap.add_argument("--model", default=os.getenv("OPENAI_MODEL","gpt-4.1-mini"))
ap.add_argument("--params", default="params.json")
ap.add_argument("--symbol", default=None, help="Например: ETH/USDT (single-режим)")
ap.add_argument("--multi", action="store_true", help="Мульти-анализ по пулу (анализ + JSON в конце)")
args = ap.parse_args()

# ================= MULTI MODE =================
if args.multi:
    # --- MULTI MODE: свободный анализ Ани + JSON в конце ---
    system_prompt = read_file("prompt_analysis.txt")  # Аня v7.x (мульти-пул)

    # Собираем снапшот из ./status — это источник истины
    snapshot = snapshot_from_status()
    if not snapshot:
        # Фоллбек (редко): вручную соберём мини-блок
        btc = get_pair_ticker("BTC/USDT")
        eth = get_pair_ticker("ETH/USDT")
        pool = get_pool_snapshot()
        time_str = current_msk()
        ctx = []
        ctx.append(f"Время (МСК): {time_str}")
        ctx.append("Контекст BTC/ETH (используй ТОЛЬКО эти значения; числовые уровни/диапазоны не придумывать):")
        ctx.append(f"BTC/USDT: last={btc['last']}, change_24h={btc['change']}%")
        ctx.append(f"ETH/USDT: last={eth['last']}, change_24h={eth['change']}%")
        ctx.append("")
        ctx.append("Котировки альт-пула (USDT, 24h %):")
        for k, v in pool.items():
            ctx.append(f"{k}: last={v['last']}, change_24h={v['change']}%")
        snapshot = "\n".join(ctx)

    # Явно добавим строку с 24h% BTC/ETH, которую LLM ДОЛЖНА использовать в market_context
    btc_info = get_pair_ticker("BTC/USDT")
    eth_info = get_pair_ticker("ETH/USDT")
    btc_eth_line = (
        f"\n[BTC_ETH_24H]\n"
        f"BTC change_24h={btc_info['change']}%, ETH change_24h={eth_info['change']}% "
        f"(используй РОВНО эти проценты в поле market_context)\n"
    )

    # Логируем снапшот (для отладки)
    try:
        with open("snapshot.txt","w",encoding="utf-8") as f:
            f.write(snapshot + "\n")
    except Exception:
        pass
    print("\n=== [SNAPSHOT ДЛЯ LLM] ===\n" + snapshot + "\n==========================\n")

    # user_prompt + NEWS + NEWS_FOCUS

    news_block = get_news_block(12)



    # LESSONS: загружаем и печатаем факт подключения (clean)
    lessons_text, lessons_count, lessons_path = load_lessons()
    print("[LESSONS] " + (f"included from {lessons_path} ({lessons_count} lines)" if lessons_count else "not available"))
    # финальный user_prompt для MULTI

    user_prompt = (

        ((lessons_text + "\n") if lessons_text else "") +

        snapshot + btc_eth_line + "\n"

        + "Требования к описанию BTC/ETH: опирайся только на last и change_24h; не указывай числовые уровни/диапазоны, которых нет во входе. "

        + "Оцени общий фон (risk-on/нейтрально/risk-off) исходя из снапшота. "

        + "Сначала выдай свободный аналитический обзор по пулу (4–6 абзацев). "

        + "В конце — чистый JSON-блок сигнала по указанной схеме (без текста вокруг)."

        + news_block

    )


    # Строгий стиль для блоков + формат symbol/time_msk
    user_prompt += (
        "\n\n=== OUTPUT STYLE REQUIREMENTS ===\n"
        "- symbol: строго в формате TICKER/USDT из пула (например, LINK/USDT; НЕ LINKUSDT).\n"
        "- time_msk: формат ровно 'dd.mm.yyyy, HH:MM' по МСК.\n"
        "- news_context: выдай 1–3 пункта из [NEWS]/NEWS_FOCUS. Каждый пункт в формате: "
        "\"- [impact:+/−/neutral] краткий заголовок — зачем это важно для выбранного актива (≤15 слов)\". "
        "Используй только факты из [NEWS], не придумывай уровни/цифры.\n"
        "- market_context: используй блок [BTC_ETH_24H] с процента́ми КАК ЕСТЬ. Строка вида: "
        "\"BTC change_24h=<..>%, ETH change_24h=<..>% — risk-on/neutral/risk-off\" + 1 короткое заключение, "
        "как это влияет на выбранный актив.\n"
        "- Если по выбранному активу нет прямых новостей, бери макро/секторные из [NEWS], но поясни релевантность.\n"
        "- Избегай общих фраз; делай вывод конкретным: что именно меняет новость/контекст в сетапе.\n"
    )

    focus = build_news_focus("", news_block)
    if focus:
        user_prompt += "\nNEWS_FOCUS (top-3):\n" + focus + "\n"

    resp = client.chat.completions.create(
        model=args.model,
        messages=[
            {"role":"system","content":system_prompt},
            {"role":"user","content":user_prompt},
        ],
        temperature=0.85,
        top_p=0.95,
        presence_penalty=0.4,
        frequency_penalty=0.2,
        seed=7,
    )
    print(resp.choices[0].message.content)
    sys.exit(0)

# ================= SINGLE MODE =================
# --- SINGLE MODE: строгий JSON по одному активу ---
system_prompt = read_file("prompt_system.txt")  # строгий JSON-контракт
anna_prompt   = read_file("prompt_anna.txt")    # мозг Ани (single)

payload = {}
if os.path.exists(args.params):
    with open(args.params,"r",encoding="utf-8") as f:
        try:
            payload = json.load(f)
        except json.JSONDecodeError:
            print("ERROR: params.json is not valid JSON", file=sys.stderr); sys.exit(1)

# enforce hints
payload.setdefault("hints", {})
if args.symbol:
    payload["hints"]["symbol"] = args.symbol
    # inject live last price for single-mode to avoid hallucinated numbers
    _sym = payload["hints"]["symbol"]
    try:
        _last = get_pair_ticker(_sym).get("last")
    except Exception:
        _last = None
    if _last is not None:
        try:
            _val = float(_last)
            _prec = 4 if _val < 1 else (3 if _val < 10 else 2)
            payload["hints"]["price"] = round(_val, _prec)
            payload["hints"]["price_source"] = "live"
        except Exception:
            pass

payload["hints"].setdefault("time_msk", current_msk())

# базовый user_prompt
base_user_prompt = (
    "Сгенерируй один JSON по заданной схеме. "
    "Используй hints как обязательные значения; constraints — как жёсткие ограничения. "
    f"Поле time_msk установи РОВНО в это значение: {payload['hints']['time_msk']}. "
    "Поле price, если задано, используй РОВНО как задано. "
    "Если явных новостей нет (hints.news нет) — верни \"news_context\": [].\n"
    "Входные данные:\n" + json.dumps(payload, ensure_ascii=False)
)

# NEWS → в prompt
news_block = get_news_block(12)

# LESSONS → перед base_user_prompt, если есть
lessons_text, _ln, _lp = load_lessons()

# финальный user_prompt для SINGLE
user_prompt = (
    ((lessons_text + "\n") if lessons_text else "")
    + base_user_prompt
    + news_block
)

# стиль + формат symbol/time_msk
user_prompt += (
    "\n\n=== OUTPUT STYLE REQUIREMENTS ===\n"
    "- symbol: строго в формате TICKER/USDT из пула (например, LINK/USDT; НЕ LINKUSDT).\n"
    "- time_msk: формат ровно 'dd.mm.yyyy, HH:MM' по МСК.\n"
    "- news_context: выдай 1–3 пункта из [NEWS]/NEWS_FOCUS. Каждый пункт в формате: "
    "\"- [impact:+/−/neutral] краткий заголовок — зачем это важно для выбранного актива (≤15 слов)\". "
    "Используй только факты из [NEWS], не придумывай уровни/цифры.\n"
    "- market_context: если присутствует блок [BTC_ETH_24H] — используй проценты КАК ЕСТЬ; иначе проценты из снапшота.\n"
)

focus = build_news_focus(payload.get("hints",{}).get("symbol",""), news_block)
if focus:
    user_prompt += "\nNEWS_FOCUS (top-3):\n" + focus + "\n"

resp = client.chat.completions.create(
    model=args.model,
    response_format={"type":"json_object"},
    messages=[
        {"role":"system","content":system_prompt},
        {"role":"system","content":anna_prompt},
        {"role":"user","content":user_prompt},
    ],
    temperature=0.4,
    top_p=0.85
)
print(resp.choices[0].message.content)
