#!/usr/bin/env python3
from pathlib import Path
auto_extra = Path("auto_feedback/lessons/Auto_Lessons.md")
import json, os, datetime
from pathlib import Path

# === –ü–∞—Ä–∞–º–µ—Ç—Ä—ã ===
BASE = Path(__file__).resolve().parent
AF_DIR = BASE / "auto_feedback"
LESSONS_DIR = AF_DIR / "lessons"
ROLLING_PATH = LESSONS_DIR / "rolling.jsonl"
LESSONS_MD   = LESSONS_DIR / "LESSONS_FOR_LLM.md"
# –ª–∏–º–∏—Ç—ã
ROLLING_MAX  = 10000   # safety cap, —á—Ç–æ–±—ã —Ñ–∞–π–ª –±–µ—Å–∫–æ–Ω–µ—á–Ω–æ –Ω–µ —Ä–æ—Å
LESSONS_MAX  = 200     # —Å–∫–æ–ª—å–∫–æ —Å—Ç—Ä–æ–∫ –≤–∫–ª—é—á–∞–µ–º –≤ Markdown

AF_DIR.mkdir(exist_ok=True, parents=True)
LESSONS_DIR.mkdir(exist_ok=True, parents=True)

# --- –≤–∞–ª–∏–¥–∞—Ü–∏—è –¥–∞–Ω–Ω—ã—Ö —Å–Ω–∏–ø–ø–µ—Ç–∞ ---
RESULT_OK = {"win", "loss", "breakeven", "skip"}
EXIT_OK   = {"tp1","tp2","sl","breakeven","no_entry","cancel","manual","timeout"}

def validate(d: dict) -> dict:
    # –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è (–º–∏–Ω–∏–º—É–º –¥–ª—è v1)
    for k in ("pair","result"):
        if k not in d:
            raise ValueError(f"missing field: {k}")
    if d["result"] not in RESULT_OK:
        raise ValueError("result must be one of {'breakeven','loss','skip','win'}")
    if "exit_reason" in d and d["exit_reason"] and d["exit_reason"] not in EXIT_OK:
        raise ValueError("wrong exit_reason")

    # –Ω–æ—Ä–º–∞–ª–∏–∑—É–µ–º datetime –≤ ISO –µ—Å–ª–∏ –Ω–µ—Ç
    if not d.get("datetime"):
        d["datetime"] = datetime.datetime.now(datetime.timezone.utc).isoformat()
    return d
    from pathlib import Path
    if auto_extra.exists():
        with open(auto_extra, "r", encoding="utf-8") as f:
            text += "\n" + f.read().strip() + "\n"

def _month_dir(dt: datetime.datetime) -> Path:
    month = dt.strftime("%Y-%m")
    p = AF_DIR / month
    p.mkdir(parents=True, exist_ok=True)
    return p
    from pathlib import Path
    if auto_extra.exists():
        with open(auto_extra, "r", encoding="utf-8") as f:
            text += "\n" + f.read().strip() + "\n"

def _safe_pair(pair: str) -> str:
    return (pair or "UNKNOWN").replace("/","_").replace(" ","")
    from pathlib import Path
    if auto_extra.exists():
        with open(auto_extra, "r", encoding="utf-8") as f:
            text += "\n" + f.read().strip() + "\n"

def rebuild_lessons_md():
    """
    –°–±–æ—Ä–∫–∞ –∞–≤—Ç–æ-—É—Ä–æ–∫–æ–≤:
    - —á–∏—Ç–∞–µ—Ç auto_feedback/lessons/rolling.jsonl (feedback-—Å–Ω–∏–ø–ø–µ—Ç—ã)
    - —Ä–µ–Ω–¥–µ—Ä–∏—Ç –∫—Ä–∞—Ç–∫–∏–µ —Å—Ç—Ä–æ–∫–∏
    - –î–û–ë–ê–í–õ–Ø–ï–¢ –≤ –∫–æ–Ω–µ—Ü AUTO-–±–ª–æ–∫ (v1.8 –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω–æ, –∏–Ω–∞—á–µ v1.6), –µ—Å–ª–∏ –æ–Ω —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —á–∏—Å–ª–æ feedback-—ç–ª–µ–º–µ–Ω—Ç–æ–≤ (–±–µ–∑ AUTO-–±–ª–æ–∫–∞).
    """
    import json
    from pathlib import Path

    ROLLING_PATH = Path("auto_feedback/lessons/rolling.jsonl")
    OUT_PATH     = Path("auto_feedback/lessons/LESSONS_FOR_LLM.md")
    AUTO_18      = Path("auto_feedback/lessons/Auto_Lessons.md")
    AUTO_16      = Path("auto_feedback/lessons/Auto_Lessons.md")

    header = "# [LESSONS]\n–£—á–∏—Ç—ã–≤–∞–π –ø–æ–≤—Ç–æ—Ä—è—é—â–∏–µ—Å—è –æ—à–∏–±–∫–∏ –∏ –ø—Ä–∏–Ω—è—Ç—ã–µ —Ñ–∏–∫—Å—ã –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Å–∏–≥–Ω–∞–ª–∞. –ù–∏–∂–µ –ø–æ—Å–ª–µ–¥–Ω–∏–µ —Å–ª—É—á–∞–∏ (—Å–≤–µ–∂–∏–µ –≤–Ω–∏–∑—É):\n\n"

    items = []
    if ROLLING_PATH.exists():
        for ln in ROLLING_PATH.read_text(encoding="utf-8").splitlines():
            ln = ln.strip()
            if not ln:
                continue
            try:
                d = json.loads(ln)
            except Exception:
                continue
            dt    = d.get("datetime") or d.get("ts") or ""
            pair  = d.get("pair", "")
            res   = d.get("result", "")
            issues= d.get("issues") or []
            fixes = d.get("fixes")  or []
            if not isinstance(issues, list): issues = []
            if not isinstance(fixes, list):  fixes  = []
            issues_str = ", ".join(issues) if issues else "none"
            fixes_str  = ", ".join(fixes)  if fixes  else "none"
            note = (d.get("pnl") or {}).get("note") if isinstance(d.get("pnl"), dict) else ""
            if not note:
                note = d.get("comment", "") or "‚Äî"
            items.append(f"- {dt} ‚Ä¢ {pair} ‚Ä¢ result={res}; issues=[{issues_str}]; fixes=[{fixes_str}]; note: {note}")

    # –æ–≥—Ä–∞–Ω–∏—á–∏–º —Ö–≤–æ—Å—Ç–æ–º, —á—Ç–æ–±—ã –ø—Ä–æ–º–ø—Ç –Ω–µ —Ä–∞–∑–¥—É–≤–∞–ª—Å—è
    text = header + "\n".join(items[-20:]) + "\n"

    # –ø—Ä–∏–∫–ª–µ–∏–≤–∞–µ–º AUTO (v1.8 > v1.6)
    for auto_path in (AUTO_18, AUTO_16):
        if auto_path.exists():
            auto_txt = auto_path.read_text(encoding="utf-8").strip()
            if auto_txt:
                text += "\n" + auto_txt + "\n"
                break

    OUT_PATH.write_text(text, encoding="utf-8")
    return len(items)


def _cap_rolling_if_needed():
    """–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä rolling.jsonl –≤ —Ä–∞–∑—É–º–Ω—ã—Ö –≥—Ä–∞–Ω–∏—Ü–∞—Ö."""
    try:
        lines = ROLLING_PATH.read_text(encoding="utf-8").splitlines()
    except Exception:
        return
    from pathlib import Path
    if auto_extra.exists():
        with open(auto_extra, "r", encoding="utf-8") as f:
            text += "\n" + f.read().strip() + "\n"
    if len(lines) <= ROLLING_MAX:
        return
    from pathlib import Path
    if auto_extra.exists():
        with open(auto_extra, "r", encoding="utf-8") as f:
            text += "\n" + f.read().strip() + "\n"
    # –æ—Å—Ç–∞–≤–ª—è–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ ROLLING_MAX —Å—Ç—Ä–æ–∫
    ROLLING_PATH.write_text("\n".join(lines[-ROLLING_MAX:])+"\n", encoding="utf-8")

def save_feedback(data: dict) -> str:
    d = validate(dict(data))  # –∫–æ–ø–∏—è –∏ –≤–∞–ª–∏–¥–∞—Ü–∏—è

    # –≤—ã—á–∏—Å–ª—è–µ–º –∏–º—è —Ñ–∞–π–ª–∞
    now = datetime.datetime.now(datetime.timezone.utc)
    monthdir = _month_dir(now)
    pair = _safe_pair(d.get("pair"))
    # –ø—Ä–µ–¥–ø–æ—á–∏—Ç–∞–µ–º signal_id –≤ –∏–º–µ–Ω–∏, –∏–Ω–∞—á–µ —Ç–µ–∫—É—â–∏–π —à—Ç–∞–º–ø
    sid = (d.get("signal_id") or now.strftime("%Y%m%d_%H%M%S"))
    json_path = monthdir / f"feedback_{pair}_{sid}.json"

    # —Å–æ—Ö—Ä–∞–Ω—è–µ–º —Å–∞–º —Å–Ω–∏–ø–ø–µ—Ç (–∫—Ä–∞—Å–∏–≤–æ)
    json_path.write_text(json.dumps(d, ensure_ascii=False, indent=2), encoding="utf-8")

    # –¥–æ–±–∞–≤–ª—è–µ–º –≤ rolling.jsonl (–æ–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–æ–π)
    with ROLLING_PATH.open("a", encoding="utf-8") as f:
        f.write(json.dumps(d, ensure_ascii=False) + "\n")

    # –æ–≥—Ä–∞–Ω–∏—á–∏–º —Ä–∞–∑–º–µ—Ä rolling –Ω–∞ –≤—Å—è–∫–∏–π
    _cap_rolling_if_needed()

    # –ø–µ—Ä–µ—Å–æ–±–µ—Ä—ë–º LESSONS_FOR_LLM.md
    n = rebuild_lessons_md()

    print(f"‚úÖ Feedback saved: {json_path}")
    print(f"üîÅ LESSONS rebuilt: {LESSONS_MD} ({n} items)")
    return str(json_path)
    from pathlib import Path
    if auto_extra.exists():
        with open(auto_extra, "r", encoding="utf-8") as f:
            text += "\n" + f.read().strip() + "\n"

if __name__ == "__main__":
    import sys
    import fileinput
    try:
        # —á–∏—Ç–∞–µ–º JSON –∏–∑ stdin –∏–ª–∏ –ø–µ—Ä–≤–æ–≥–æ –∞—Ä–≥—É–º–µ–Ω—Ç–∞-—Ñ–∞–π–ª–∞
        if not sys.stdin.isatty():
            raw = sys.stdin.read()
            data = json.loads(raw)
        else:
            if len(sys.argv) < 2:
                raise SystemExit("Usage: feedback_writer.py < file.json")
            with open(sys.argv[1], "r", encoding="utf-8") as fh:
                data = json.load(fh)
        save_feedback(data)
    except Exception as e:
        print(f"ERROR: {e}")
        sys.exit(1)
