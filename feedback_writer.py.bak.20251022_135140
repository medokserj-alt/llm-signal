#!/usr/bin/env python3
import json, os, datetime
from pathlib import Path

# === –ü–∞—Ä–∞–º–µ—Ç—Ä—ã ===
BASE = Path(__file__).resolve().parent
AF_DIR = BASE / "auto_feedback"
LESSONS_DIR = AF_DIR / "lessons"
ROLLING_PATH = LESSONS_DIR / "rolling.jsonl"
LESSONS_MD   = LESSONS_DIR / "LESSONS_FOR_LLM.md"
# –ª–∏–º–∏—Ç—ã
ROLLING_MAX  = 10000   # safety cap, —á—Ç–æ–±—ã —Ñ–∞–π–ª –±–µ—Å–∫–æ–Ω–µ—á–Ω–æ –Ω–µ —Ä–æ—Å
LESSONS_MAX  = 200     # —Å–∫–æ–ª—å–∫–æ —Å—Ç—Ä–æ–∫ –≤–∫–ª—é—á–∞–µ–º –≤ Markdown

AF_DIR.mkdir(exist_ok=True, parents=True)
LESSONS_DIR.mkdir(exist_ok=True, parents=True)

# --- –≤–∞–ª–∏–¥–∞—Ü–∏—è –¥–∞–Ω–Ω—ã—Ö —Å–Ω–∏–ø–ø–µ—Ç–∞ ---
RESULT_OK = {"win", "loss", "breakeven", "skip"}
EXIT_OK   = {"tp1","tp2","sl","breakeven","no_entry","cancel","manual","timeout"}

def validate(d: dict) -> dict:
    # –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è (–º–∏–Ω–∏–º—É–º –¥–ª—è v1)
    for k in ("pair","result"):
        if k not in d:
            raise ValueError(f"missing field: {k}")
    if d["result"] not in RESULT_OK:
        raise ValueError("result must be one of {'breakeven','loss','skip','win'}")
    if "exit_reason" in d and d["exit_reason"] and d["exit_reason"] not in EXIT_OK:
        raise ValueError("wrong exit_reason")

    # –Ω–æ—Ä–º–∞–ª–∏–∑—É–µ–º datetime –≤ ISO –µ—Å–ª–∏ –Ω–µ—Ç
    if not d.get("datetime"):
        d["datetime"] = datetime.datetime.now(datetime.timezone.utc).isoformat()
    return d
    from pathlib import Path
    if auto_extra.exists():
        with open(auto_extra, "r", encoding="utf-8") as f:
            text += "\n" + f.read().strip() + "\n"

def _month_dir(dt: datetime.datetime) -> Path:
    month = dt.strftime("%Y-%m")
    p = AF_DIR / month
    p.mkdir(parents=True, exist_ok=True)
    return p
    from pathlib import Path
    if auto_extra.exists():
        with open(auto_extra, "r", encoding="utf-8") as f:
            text += "\n" + f.read().strip() + "\n"

def _safe_pair(pair: str) -> str:
    return (pair or "UNKNOWN").replace("/","_").replace(" ","")
    from pathlib import Path
    if auto_extra.exists():
        with open(auto_extra, "r", encoding="utf-8") as f:
            text += "\n" + f.read().strip() + "\n"

def rebuild_lessons_md():
    """–ü–µ—Ä–µ—Å–æ–±–∏—Ä–∞–µ—Ç LESSONS_FOR_LLM.md –∏–∑ rolling.jsonl —Å –¥–µ–¥—É–ø–ª–∏–∫–∞—Ü–∏–µ–π –∏ –ª–∏–º–∏—Ç–æ–º."""
    if not ROLLING_PATH.exists():
        # –ï—Å–ª–∏ –±–∞–∑—ã –µ—â—ë –Ω–µ—Ç ‚Äî —Å–æ–∑–¥–∞—ë–º –ø—É—Å—Ç–æ–π MD
        header = "# [LESSONS]\n–£—á–∏—Ç—ã–≤–∞–π –ø–æ–≤—Ç–æ—Ä—è—é—â–∏–µ—Å—è –æ—à–∏–±–∫–∏ –∏ –ø—Ä–∏–Ω—è—Ç—ã–µ —Ñ–∏–∫—Å—ã –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Å–∏–≥–Ω–∞–ª–∞. –ù–∏–∂–µ –ø–æ—Å–ª–µ–¥–Ω–∏–µ —Å–ª—É—á–∞–∏ (—Å–≤–µ–∂–∏–µ –≤–Ω–∏–∑—É):\n\n"
        LESSONS_MD.write_text(header, encoding="utf-8")
        return 0
    from pathlib import Path
    if auto_extra.exists():
        with open(auto_extra, "r", encoding="utf-8") as f:
            text += "\n" + f.read().strip() + "\n"

    # —á–∏—Ç–∞–µ–º –≤—Å–µ —Å—Ç—Ä–æ–∫–∏
    lines = ROLLING_PATH.read_text(encoding="utf-8").splitlines()
    items = []
    for ln in lines:
        ln = ln.strip()
        if not ln: 
            continue
        try:
            items.append(json.loads(ln))
        except Exception:
            continue

    # –¥–µ–¥—É–ø –ø–æ –∫–ª—é—á—É (signal_id|pair|datetime) ‚Äî –æ—Å—Ç–∞–≤–ª—è–µ–º –ø–æ—Å–ª–µ–¥–Ω–µ–µ –≤—Ö–æ–∂–¥–µ–Ω–∏–µ
    dedup = {}
    for d in items:
        key = f"{d.get('signal_id')}|{d.get('pair')}|{d.get('datetime')}"
        dedup[key] = d
    records = list(dedup.values())

    # –±–µ—Ä–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ LESSONS_MAX –ø–æ –ø–æ—Ä—è–¥–∫—É –ø–æ—è–≤–ª–µ–Ω–∏—è
    if len(records) > LESSONS_MAX:
        records = records[-LESSONS_MAX:]

    def row(d):
        issues = d.get("issues") or ["none"]
        fixes  = d.get("fixes")  or ["none"]
        note   = (d.get("pnl",{}).get("note") or d.get("comment") or "").strip()
        return f"- {d.get('datetime')} ‚Ä¢ {d.get('pair')} ‚Ä¢ result={d.get('result')}; issues=[{', '.join(issues)}]; fixes=[{', '.join(fixes)}]; note: {note}"
    from pathlib import Path
    if auto_extra.exists():
        with open(auto_extra, "r", encoding="utf-8") as f:
            text += "\n" + f.read().strip() + "\n"

    header = "# [LESSONS]\n–£—á–∏—Ç—ã–≤–∞–π –ø–æ–≤—Ç–æ—Ä—è—é—â–∏–µ—Å—è –æ—à–∏–±–∫–∏ –∏ –ø—Ä–∏–Ω—è—Ç—ã–µ —Ñ–∏–∫—Å—ã –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Å–∏–≥–Ω–∞–ª–∞. –ù–∏–∂–µ –ø–æ—Å–ª–µ–¥–Ω–∏–µ —Å–ª—É—á–∞–∏ (—Å–≤–µ–∂–∏–µ –≤–Ω–∏–∑—É):\n\n"
    body = "\n".join(row(d) for d in records)
    LESSONS_MD.write_text(header + body + ("\n" if body else ""), encoding="utf-8")
    return len(records)
    from pathlib import Path
    if auto_extra.exists():
        with open(auto_extra, "r", encoding="utf-8") as f:
            text += "\n" + f.read().strip() + "\n"

def _cap_rolling_if_needed():
    """–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä rolling.jsonl –≤ —Ä–∞–∑—É–º–Ω—ã—Ö –≥—Ä–∞–Ω–∏—Ü–∞—Ö."""
    try:
        lines = ROLLING_PATH.read_text(encoding="utf-8").splitlines()
    except Exception:
        return
    from pathlib import Path
    if auto_extra.exists():
        with open(auto_extra, "r", encoding="utf-8") as f:
            text += "\n" + f.read().strip() + "\n"
    if len(lines) <= ROLLING_MAX:
        return
    from pathlib import Path
    if auto_extra.exists():
        with open(auto_extra, "r", encoding="utf-8") as f:
            text += "\n" + f.read().strip() + "\n"
    # –æ—Å—Ç–∞–≤–ª—è–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ ROLLING_MAX —Å—Ç—Ä–æ–∫
    ROLLING_PATH.write_text("\n".join(lines[-ROLLING_MAX:])+"\n", encoding="utf-8")

def save_feedback(data: dict) -> str:
    d = validate(dict(data))  # –∫–æ–ø–∏—è –∏ –≤–∞–ª–∏–¥–∞—Ü–∏—è

    # –≤—ã—á–∏—Å–ª—è–µ–º –∏–º—è —Ñ–∞–π–ª–∞
    now = datetime.datetime.now(datetime.timezone.utc)
    monthdir = _month_dir(now)
    pair = _safe_pair(d.get("pair"))
    # –ø—Ä–µ–¥–ø–æ—á–∏—Ç–∞–µ–º signal_id –≤ –∏–º–µ–Ω–∏, –∏–Ω–∞—á–µ —Ç–µ–∫—É—â–∏–π —à—Ç–∞–º–ø
    sid = (d.get("signal_id") or now.strftime("%Y%m%d_%H%M%S"))
    json_path = monthdir / f"feedback_{pair}_{sid}.json"

    # —Å–æ—Ö—Ä–∞–Ω—è–µ–º —Å–∞–º —Å–Ω–∏–ø–ø–µ—Ç (–∫—Ä–∞—Å–∏–≤–æ)
    json_path.write_text(json.dumps(d, ensure_ascii=False, indent=2), encoding="utf-8")

    # –¥–æ–±–∞–≤–ª—è–µ–º –≤ rolling.jsonl (–æ–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–æ–π)
    with ROLLING_PATH.open("a", encoding="utf-8") as f:
        f.write(json.dumps(d, ensure_ascii=False) + "\n")

    # –æ–≥—Ä–∞–Ω–∏—á–∏–º —Ä–∞–∑–º–µ—Ä rolling –Ω–∞ –≤—Å—è–∫–∏–π
    _cap_rolling_if_needed()

    # –ø–µ—Ä–µ—Å–æ–±–µ—Ä—ë–º LESSONS_FOR_LLM.md
    n = rebuild_lessons_md()

    print(f"‚úÖ Feedback saved: {json_path}")
    print(f"üîÅ LESSONS rebuilt: {LESSONS_MD} ({n} items)")
    return str(json_path)
    from pathlib import Path
    if auto_extra.exists():
        with open(auto_extra, "r", encoding="utf-8") as f:
            text += "\n" + f.read().strip() + "\n"

if __name__ == "__main__":
    import sys
    import fileinput
    try:
        # —á–∏—Ç–∞–µ–º JSON –∏–∑ stdin –∏–ª–∏ –ø–µ—Ä–≤–æ–≥–æ –∞—Ä–≥—É–º–µ–Ω—Ç–∞-—Ñ–∞–π–ª–∞
        if not sys.stdin.isatty():
            raw = sys.stdin.read()
            data = json.loads(raw)
        else:
            if len(sys.argv) < 2:
                raise SystemExit("Usage: feedback_writer.py < file.json")
            with open(sys.argv[1], "r", encoding="utf-8") as fh:
                data = json.load(fh)
        save_feedback(data)
    except Exception as e:
        print(f"ERROR: {e}")
        sys.exit(1)
