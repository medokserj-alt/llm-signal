#!/usr/bin/env python3
import os, time, subprocess, pathlib, re, html as htmllib, json
from datetime import datetime
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.constants import ParseMode
from telegram.ext import Application, CommandHandler, CallbackQueryHandler, ContextTypes
from dotenv import load_dotenv

# ===== –±–∞–∑–æ–≤–∞—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è =====
BASE = pathlib.Path(__file__).resolve().parent
load_dotenv(BASE/".env.tg")

BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
CHANNEL   = os.getenv("TELEGRAM_TARGET_CHANNEL")

def parse_allowed_ids() -> list[int]:
    ids = []
    raw_multi  = os.getenv("TELEGRAM_ALLOWED_USER_IDS", "")
    raw_legacy = os.getenv("TELEGRAM_ALLOWED_USER_ID", "")
    for raw in (raw_multi, raw_legacy):
        for x in raw.replace(";", ",").split(","):
            x = x.strip()
            if x and (x.lstrip("-").isdigit()):
                try:
                    ids.append(int(x))
                except:
                    pass
    return list(dict.fromkeys(ids))

ALLOWED_UIDS = parse_allowed_ids()

def latest(pattern: str):
    files = list(BASE.glob(pattern))
    return max(files, key=lambda p: p.stat().st_mtime) if files else None

def html_file_to_tg_text(p: pathlib.Path, max_len=4000):
    s = p.read_text(encoding="utf-8")
    m = re.search(r'<body[^>]*>(.*?)</body>', s, flags=re.S|re.I)
    s = m.group(1) if m else s
    s = re.sub(r'<\s*(strong)\s*>', '<b>', s, flags=re.I)
    s = re.sub(r'<\s*/\s*(strong)\s*>', '</b>', s, flags=re.I)
    s = re.sub(r'<\s*(em)\s*>', '<i>', s, flags=re.I)
    s = re.sub(r'<\s*/\s*(em)\s*>', '</i>', s, flags=re.I)
    s = re.sub(r'<\s*br\s*/?>', '\n', s, flags=re.I)
    s = re.sub(r'</\s*p\s*>', '\n\n', s, flags=re.I)
    s = re.sub(r'<\s*p[^>]*>', '', s, flags=re.I)
    s = re.sub(r'<[^>]+>', '', s)
    s = htmllib.unescape(s)
    s = re.sub(r'[ \t]+\n', '\n', s).strip()
    chunks = []
    while s:
        chunks.append(s[:max_len])
        s = s[max_len:]
    return chunks

def md_file_to_chunks(p: pathlib.Path, max_len=4000):
    s = p.read_text(encoding="utf-8").strip()
    chunks = []
    while s:
        chunks.append(s[:max_len])
        s = s[max_len:]
    return chunks

def is_allowed(uid: int) -> bool:
    return (uid in ALLOWED_UIDS) if ALLOWED_UIDS else False

# ===== feedback (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ) =====
try:
    from feedback_writer import save_feedback  # —Ñ–∞–π–ª –º–æ–∂–µ—Ç –æ—Ç—Å—É—Ç—Å—Ç–≤–æ–≤–∞—Ç—å ‚Äî –æ–∫
    FEEDBACK_AVAILABLE = True
except Exception:
    save_feedback = None
    FEEDBACK_AVAILABLE = False

# ===== JSON-–ø–∞—Ä—Å–µ—Ä –∏–∑ —Ç–µ–∫—Å—Ç–∞ /feedback =====
def extract_json_from_text(text: str) -> str | None:
    if not text:
        return None
    text = re.sub(r'^\s*/feedback\s*', '', text, flags=re.I).strip()
    if not text:
        return None
    fence = re.search(r"```(?:json)?\s*(.+?)```", text, flags=re.S|re.I)
    if fence:
        return fence.group(1).strip()
    inline = re.search(r"`\s*(\{.+\})\s*`", text, flags=re.S)
    if inline:
        return inline.group(1).strip()
    if text.lstrip().startswith("{") and text.rstrip().endswith("}"):
        return text.strip()
    return None

# ===== main menu keyboard (–æ–¥–Ω–∞ –∫–Ω–æ–ø–∫–∞ –≤ —Å—Ç—Ä–æ–∫–µ, ¬´–∫—Ä—É–ø–Ω–µ–µ¬ª) =====
def main_menu_kb():
    from telegram import ReplyKeyboardMarkup, KeyboardButton
    kb = [
        [KeyboardButton("üìä –°–∏–≥–Ω–∞–ª")],
        [KeyboardButton("üîç FULL –∞–Ω–∞–ª–∏–∑")],
        [KeyboardButton("üí¨ Feedback")]
    ]
    return ReplyKeyboardMarkup(kb, resize_keyboard=True)
# ===== Signal submenu (–ø–∞—Ä—ã –±–µ–∑ /USDT –≤ —Ç–µ–∫—Å—Ç–µ, –Ω–æ —Å /USDT –≤ callback) =====
def signal_menu_kb():
    try:
        pool = json.load(open(BASE/"pool.json","r",encoding="utf-8"))["pool"]
    except Exception:
        pool = ["BTC/USDT","ETH/USDT","SOL/USDT","AVAX/USDT","APT/USDT","AAVE/USDT","LINK/USDT","TON/USDT","ARB/USDT"]
    rows = []
    for sym in pool:
        label = sym.split("/")[0]  # —Ç–µ–∫—Å—Ç –±–µ–∑ /USDT
        rows.append([InlineKeyboardButton(f"‚Ä¢ {label}", callback_data=f"signal_pair:{sym}")])
    rows.append([InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="back_to_main")])
    return InlineKeyboardMarkup(rows)

# ===== handlers =====
async def whoami(update: Update, context: ContextTypes.DEFAULT_TYPE):
    uid = update.effective_user.id if update.effective_user else None
    await update.message.reply_text(
        "whoami\n"
        f"- your id: {uid}\n"
        f"- allowed: {ALLOWED_UIDS}\n"
        f"- channel: {CHANNEL}"
    )

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    uid = update.effective_user.id if update.effective_user else 0
    if not is_allowed(uid):
        await update.message.reply_text("–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â—ë–Ω.")
        return
    # –ü—É—Å—Ç–æ–π —Ç–µ–∫—Å—Ç (–ø–æ—á—Ç–∏ –Ω–µ–≤–∏–¥–∏–º—ã–π —Å–∏–º–≤–æ–ª), —Ç–æ–ª—å–∫–æ –∫–Ω–æ–ø–∫–∏
    await update.message.reply_text("üìã –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", reply_markup=main_menu_kb())

async def back_to_main_cb(update: Update, context: ContextTypes.DEFAULT_TYPE):
    q = update.callback_query
    await q.answer()
    await q.message.edit_text("‚Äé", reply_markup=main_menu_kb())

async def open_signal_cb(update: Update, context: ContextTypes.DEFAULT_TYPE):
    q = update.callback_query
    uid = update.effective_user.id if update.effective_user else 0
    if not is_allowed(uid):
        await q.answer("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞", show_alert=True); return
    await q.answer()
    await q.message.edit_text("‚Äé", reply_markup=signal_menu_kb())

async def run_full_cb(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    uid = update.effective_user.id if update.effective_user else 0
    if not is_allowed(uid):
        await query.answer("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞", show_alert=True); return
    await query.answer()
    msg = await query.message.reply_text("–ó–∞–ø—É—Å–∫–∞—é FULL –∞–Ω–∞–ª–∏–∑‚Ä¶ —ç—Ç–æ –∑–∞–π–º—ë—Ç –Ω–µ–º–Ω–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏.")

    t0 = time.time()
    proc = subprocess.run(
        ["bash","-lc","cd ~/llm-signal && ./signal full"],
        capture_output=True, text=True, timeout=900
    )
    t1 = time.time()

    tail = "\n".join(proc.stdout.strip().splitlines()[-20:])
    safe_tail = htmllib.escape(tail)
    await msg.edit_text(f"–ì–æ—Ç–æ–≤–æ –∑–∞ {t1-t0:.1f}s\n<b>–•–≤–æ—Å—Ç –ª–æ–≥–∞:</b>\n<pre>{safe_tail}</pre>",
                        parse_mode=ParseMode.HTML)

    analysis = latest("analysis_*.md")
    sig_html = latest("signal_*.html")

    if analysis:
        header = f"üìù LLM Full –∞–Ω–∞–ª–∏–∑ ‚Ä¢ {datetime.now().strftime('%d.%m.%Y %H:%M')}\n\n"
        parts = md_file_to_chunks(analysis)
        await context.bot.send_message(chat_id=CHANNEL, text=header + parts[0])
        for chunk in parts[1:]:
            await context.bot.send_message(chat_id=CHANNEL, text=chunk)

    if sig_html:
        parts = html_file_to_tg_text(sig_html)
        parts[0] = "üì£ –°–∏–≥–Ω–∞–ª\n\n" + parts[0]
        await context.bot.send_message(chat_id=CHANNEL, text=parts[0], parse_mode=ParseMode.HTML)
        for chunk in parts[1:]:
            await context.bot.send_message(chat_id=CHANNEL, text=chunk, parse_mode=ParseMode.HTML)

async def signal_pair_cb(update: Update, context: ContextTypes.DEFAULT_TYPE):
    q = update.callback_query
    uid = update.effective_user.id if update.effective_user else 0
    if not is_allowed(uid):
        await q.answer("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞", show_alert=True); return
    await q.answer()

    m = re.match(r"^signal_pair:(.+)$", q.data or "")
    if not m:
        await q.message.reply_text("–û—à–∏–±–∫–∞: –Ω–µ —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω —Å–∏–º–≤–æ–ª.")
        return
    symbol = m.group(1)

    msg = await q.message.reply_text(f"–ì–æ—Ç–æ–≤–ª—é —Å–∏–≥–Ω–∞–ª –ø–æ {symbol}‚Ä¶")

    # single-—Ä–µ–∂–∏–º
    proc = subprocess.run(
        ["bash","-lc", f"cd ~/llm-signal && ./signal --symbol '{symbol}'"],
        capture_output=True, text=True, timeout=600
    )

    # –æ—Ç–ø—Ä–∞–≤–∫–∞ –≤ –∫–∞–Ω–∞–ª (–∫–∞–∫ —Ä–∞–Ω—å—à–µ)
    sig_html = latest("signal_*.html")
    if sig_html:
        parts = html_file_to_tg_text(sig_html)
        parts[0] = "üì£ –°–∏–≥–Ω–∞–ª\n\n" + parts[0]
        await context.bot.send_message(chat_id=CHANNEL, text=parts[0], parse_mode=ParseMode.HTML)
        for chunk in parts[1:]:
            await context.bot.send_message(chat_id=CHANNEL, text=chunk, parse_mode=ParseMode.HTML)

    tail = "\n".join(proc.stdout.strip().splitlines()[-20:])
    safe_tail = htmllib.escape(tail or "(–ª–æ–≥ –ø—É—Å—Ç)")
    await msg.edit_text(f"–ì–æ—Ç–æ–≤–æ\n<pre>{safe_tail}</pre>", parse_mode=ParseMode.HTML)

async def feedback_howto_cb(update: Update, context: ContextTypes.DEFAULT_TYPE):
    q = update.callback_query
    uid = update.effective_user.id if update.effective_user else 0
    if not is_allowed(uid):
        await q.answer("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞", show_alert=True); return
    await q.answer()
    if not FEEDBACK_AVAILABLE:
        await q.message.reply_text("‚ùå feedback_writer.py –Ω–µ –Ω–∞–π–¥–µ–Ω. –î–æ–±–∞–≤—å —Ñ–∞–π–ª –∏ –ø–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏ –±–æ—Ç–∞.",
                                   reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="back_to_main")]]))
        return

    example = (
        "/feedback ```json\n"
        "{\n"
        '  "signal_id": "20251021_152045",\n'
        '  "pair": "LINK/USDT",\n'
        '  "side": "long",\n'
        '  "result": "win",\n'
        '  "exit_reason": "tp2",\n'
        '  "issues": [],\n'
        '  "fixes": [],\n'
        '  "comment": "–∏–¥–µ–∞–ª—å–Ω—ã–π –≤—Ö–æ–¥ –ø–æ—Å–ª–µ EMA20",\n'
        '  "reviewer": "Anya"\n'
        "}\n"
        "```"
    )
    await q.message.reply_text(
        "–û–∫, –ø—Ä–∏—à–ª–∏ JSON —Å–Ω–∏–ø–ø–µ—Ç –∫–æ–º–∞–Ω–¥–æ–π /feedback.\n\n–ü—Ä–∏–º–µ—Ä:\n" + example,
        reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="back_to_main")]])
    )

async def feedback_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    uid = update.effective_user.id if update.effective_user else 0
    if not is_allowed(uid):
        await update.message.reply_text("–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â—ë–Ω.")
        return
    if not FEEDBACK_AVAILABLE:
        await update.message.reply_text("‚ùå feedback_writer.py –Ω–µ –Ω–∞–π–¥–µ–Ω. –î–æ–±–∞–≤—å —Ñ–∞–π–ª –∏ –ø–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏ –±–æ—Ç–∞.")
        return

    raw = update.message.text or ""
    payload = extract_json_from_text(raw)
    if not payload:
        await update.message.reply_text(
            "–ù–µ –Ω–∞—à—ë–ª JSON –≤ —Å–æ–æ–±—â–µ–Ω–∏–∏.\n"
            "–ü—Ä–∏—à–ª–∏ –≤ —Ñ–æ—Ä–º–∞—Ç–µ:\n"
            '/feedback {"signal_id":"...","pair":"LINK/USDT",...}\n'
            "–∏–ª–∏ –≤ –±–ª–æ–∫–µ ```json ... ```"
        )
        return
    try:
        data = json.loads(payload)
    except Exception as e:
        await update.message.reply_text(f"‚ùå –û—à–∏–±–∫–∞ JSON: {e}")
        return

    required = ["pair", "result"]
    missing = [k for k in required if k not in data]
    if missing:
        await update.message.reply_text(f"‚ùå –ù–µ —Ö–≤–∞—Ç–∞–µ—Ç –ø–æ–ª–µ–π: {', '.join(missing)}")
        return
    try:
        path_saved = save_feedback(data)  # –º–æ–∂–µ—Ç –≤–µ—Ä–Ω—É—Ç—å –ø—É—Ç—å –∏–ª–∏ None
    except TypeError:
        save_feedback(data)
        path_saved = None
    except Exception as e:
        await update.message.reply_text(f"‚ùå –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è: {e}")
        return

    suffix = f"\nüìÅ {path_saved}" if path_saved else ""
    await update.message.reply_text("‚úÖ Feedback —Å–æ—Ö—Ä–∞–Ω—ë–Ω." + suffix)

# ===== main =====
def main():
    if not BOT_TOKEN or not CHANNEL:
        raise SystemExit("Set TELEGRAM_BOT_TOKEN and TELEGRAM_TARGET_CHANNEL in .env.tg")
    app = Application.builder().token(BOT_TOKEN).build()

    app.add_handler(CommandHandler("whoami", whoami))
    app.add_handler(CommandHandler("start", start))

    app.add_handler(CallbackQueryHandler(back_to_main_cb, pattern="^back_to_main$"))
    app.add_handler(CallbackQueryHandler(open_signal_cb, pattern="^open_signal$"))
    app.add_handler(CallbackQueryHandler(run_full_cb, pattern="^run_full$"))
    app.add_handler(CallbackQueryHandler(signal_pair_cb, pattern=r"^signal_pair:.+"))
    app.add_handler(CallbackQueryHandler(feedback_howto_cb, pattern="^feedback_howto$"))
    app.add_handler(CommandHandler("feedback", feedback_cmd))

    app.run_polling(allowed_updates=Update.ALL_TYPES)

if __name__ == "__main__":
    main()
