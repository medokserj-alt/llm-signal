#!/usr/bin/env bash
set -euo pipefail

cd "$(dirname "$0")"
mkdir -p logs

MODEL="gpt-4.1"
PARAMS="params.json"

# Разбор: "./signal full" | "./signal LINK"
args=()
if [[ $# -gt 0 ]]; then
  if [[ "$1" == "full" ]]; then
    shift
    args+=(--multi)
  elif [[ "$1" != -* && $# -eq 1 ]]; then
    args+=(--symbol "$1")
    shift
  fi
fi
args+=("$@")

ts=$(date -u +%Y%m%d_%H%M%S)
run_log="logs/signal_${ts}.log"

# 1) Генерация + запись логов (сырой поток)
python3 get_signal_json.py --model "$MODEL" --params "$PARAMS" "${args[@]}" \
| tee "$run_log" \
| tee -a logs/last_signal.log \
> logs/stream.tmp

# 2) Извлечь ПОСЛЕДНИЙ валидный JSON из лога (баланс скобок, игнорируя строки и экранирования)
python3 - <<'PY'
import json, re, pathlib, sys

def sanitize(s: str) -> str:
    # убрать код-фенсы и BOM/CR
    s = s.replace("\ufeff","")
    s = s.replace("\r","")
    s = re.sub(r'^\s*```json\s*', '', s, flags=re.IGNORECASE|re.MULTILINE)
    s = re.sub(r'\s*```\s*$', '', s)
    # вылечить висячие запятые перед } ]
    # повторим несколько проходов, но мягко
    for _ in range(5):
        s2 = re.sub(r',\s*([}\]])', r'\1', s)
        if s2 == s:
            break
        s = s2
    return s.strip()

def find_json_candidates(text: str):
    # Вырезаем все “сырцы” между балансными { ... }
    # Учитываем строки/экранирование
    candidates = []
    n = len(text)
    i = 0
    while i < n:
        if text[i] == '{':
            depth = 0
            j = i
            in_str = False
            esc = False
            while j < n:
                ch = text[j]
                if in_str:
                    if esc:
                        esc = False
                    elif ch == '\\':
                        esc = True
                    elif ch == '"':
                        in_str = False
                else:
                    if ch == '"':
                        in_str = True
                    elif ch == '{':
                        depth += 1
                    elif ch == '}':
                        depth -= 1
                        if depth == 0:
                            # кандидат найден
                            candidates.append(text[i:j+1])
                            i = j  # ускоряем
                            break
                j += 1
        i += 1
    return candidates

log_path = pathlib.Path("logs/stream.tmp")
raw = log_path.read_text(encoding="utf-8", errors="ignore")

# Пытаемся сначала по свежему потоку; если пусто — берём сам run_log
cands = find_json_candidates(raw)
if not cands:
    lastlog = sorted(pathlib.Path("logs").glob("signal_*.log"))[-1]
    raw2 = lastlog.read_text(encoding="utf-8", errors="ignore")
    cands = find_json_candidates(raw2)

ok = None
errors = []
for chunk in reversed(cands):  # берём последний валидный
    s = sanitize(chunk)
    if not s:
        continue
    try:
        data = json.loads(s)
        ok = (data, s)
        break
    except Exception as e:
        # пробуем ещё раз после дополнительной зачистки редких артефактов:
        s2 = re.sub(r'^\s*json\s*:\s*', '', s, flags=re.IGNORECASE)
        s2 = re.sub(r'^\s*{[^"\n]*:\s*$', '', s2)  # обрубки
        try:
            data = json.loads(s2)
            ok = (data, s2)
            break
        except Exception as e2:
            errors.append((e, s[:120] + ('...' if len(s)>120 else '')))

if ok is None:
    pathlib.Path("logs/last.raw.json").write_text(raw, encoding="utf-8")
    pathlib.Path("logs/last.clean.json").write_text("", encoding="utf-8")
    sys.stderr.write("[FATAL] JSON not found/parsed; wrote logs/last.raw.json for debugging\n")
    sys.exit(2)

data, clean = ok
pathlib.Path("logs/last.raw.json").write_text(clean, encoding="utf-8")
pathlib.Path("logs/last.json").write_text(json.dumps(data, ensure_ascii=False, indent=2), encoding="utf-8")
print("[OK] extracted + validated JSON -> logs/last.json")
PY

# --- генерируем артефакты для бота (MD + HTML) ---
last_json="logs/last.json"
python3 save_analysis_text.py "$last_json" | tee -a "$run_log" || true
python3 render_strict.py "$last_json" | tee -a "$run_log" || true

echo "----------------------------------------"
echo "✅ Saved logs: $run_log"
echo "✅ Last JSON:  logs/last.json"

# --- Show tail of run log to terminal (optional) ---
LINES="${LOG_TAIL:-120}"
echo
echo "**Хвост лога (последние ${LINES} строк):**"
tail -n "${LINES}" "$run_log"
