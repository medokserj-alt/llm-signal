#!/usr/bin/env python3
import os, sys, json, argparse
from datetime import datetime
from zoneinfo import ZoneInfo
from dotenv import load_dotenv
from openai import OpenAI
import ccxt

load_dotenv()
api_key = os.getenv("OPENAI_API_KEY")
if not api_key:
    print("ERROR: OPENAI_API_KEY not set (put it in .env)", file=sys.stderr)
    sys.exit(1)
client = OpenAI(api_key=api_key)

ap = argparse.ArgumentParser()
ap.add_argument("--model", default=os.getenv("OPENAI_MODEL","gpt-4.1-mini"))
ap.add_argument("--params", default="params.json")
ap.add_argument("--symbol", default=None, help="Например: ETH/USDT (single-режим)")
ap.add_argument("--multi", action="store_true", help="Мульти-анализ по пулу (анализ + JSON в конце)")
args = ap.parse_args()

def read_file(path: str) -> str:
    with open(path, "r", encoding="utf-8") as f:
        return f.read().strip()

def current_msk() -> str:
    return datetime.now(ZoneInfo("Europe/Moscow")).strftime("%d.%m.%Y, %H:%M")

def get_pair_price(sym: str):
    bybit = ccxt.bybit(); binance = ccxt.binance()
    for ex in (bybit, binance):
        try:
            t = ex.fetch_ticker(sym)
            p = t.get("last") or ((t.get("bid")+t.get("ask"))/2 if t.get("bid") and t.get("ask") else None)
            if p is not None: return float(p)
        except Exception:
            pass
    return None

def get_pool_prices() -> dict:
    with open("pool.json","r",encoding="utf-8") as f:
        pool = json.load(f)["pool"]
    out = {}
    for sym in pool:
        p = get_pair_price(sym)
        out[sym] = round(p,6) if p is not None else None
    return out

if args.multi:
    # --- MULTI MODE: свободный анализ Ани + JSON в конце ---
    system_prompt = read_file("prompt_analysis.txt")  # Аня v7.2 (мульти-пул)

    # контекст BTC/ETH + альт-пул
    btc = get_pair_price("BTC/USDT")
    eth = get_pair_price("ETH/USDT")
    prices = get_pool_prices()

    time_str = current_msk()
    ctx = []
    ctx.append(f"Время (МСК): {time_str}")
    ctx.append("Контекст BTC/ETH (используй ТОЛЬКО эти значения; числовые диапазоны/уровни для BTC/ETH НЕ придумывать):")
    ctx.append(f"BTC/USDT: {btc}")
    ctx.append(f"ETH/USDT: {eth}")
    ctx.append("")
    ctx.append("Котировки альт-пула (USDT):")
    for k,v in prices.items():
        ctx.append(f"{k}: {v}")
    snapshot = "\n".join(ctx)

    user_prompt = (
        snapshot + "\n\n"
        "Требования к контексту BTC/ETH: опирайся только на значения выше; НЕ указывай числовые диапазоны/уровни, если они не даны. "
        "Описывай BTC/ETH качественно (нейтрально/риск-он/риск-офф, поддержка/давление), без придуманных чисел. "
        "Сначала выдай свободный аналитический обзор по пулу (4–6 абзацев). "
        "В конце — чистый JSON-блок сигнала по указанной схеме (без текста вокруг)."
    )

    resp = client.chat.completions.create(
        model=args.model,
        messages=[{"role":"system","content":system_prompt},
                  {"role":"user","content":user_prompt}],
        temperature=0.7,
    )
    print(resp.choices[0].message.content)
    sys.exit(0)

# --- SINGLE MODE: строгий JSON по одному активу ---
system_prompt = read_file("prompt_system.txt")      # строгий JSON-контракт
anna_prompt   = read_file("prompt_anna.txt")        # мозг Ани (single)
payload = {}
if os.path.exists(args.params):
    with open(args.params,"r",encoding="utf-8") as f:
        try: payload = json.load(f)
        except json.JSONDecodeError:
            print("ERROR: params.json is not valid JSON", file=sys.stderr); sys.exit(1)

# enforce hints
payload.setdefault("hints", {})
if args.symbol:
    payload["hints"]["symbol"] = args.symbol
payload["hints"].setdefault("time_msk", current_msk())

user_prompt = (
    "Сгенерируй один JSON по заданной схеме. "
    "Используй hints как обязательные значения; constraints — как жёсткие ограничения. "
    f"Поле time_msk установи РОВНО в это значение: {payload['hints']['time_msk']}. "
    "Поле price, если задано, используй РОВНО как задано. "
    "Если явных новостей нет (hints.news нет) — верни \"news_context\": [].\n"
    "Входные данные:\n" + json.dumps(payload, ensure_ascii=False)
)

resp = client.chat.completions.create(
    model=args.model,
    response_format={"type":"json_object"},
    messages=[
        {"role":"system","content":system_prompt},
        {"role":"system","content":anna_prompt},
        {"role":"user","content":user_prompt},
    ],
    temperature=0.35,
)
print(resp.choices[0].message.content)
