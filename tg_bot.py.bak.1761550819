#!/usr/bin/env python3
import os, time, subprocess, re, html as htmllib, json
from datetime import datetime
from pathlib import Path
from dotenv import load_dotenv
from telegram import Update, KeyboardButton, ReplyKeyboardMarkup
from telegram.constants import ParseMode
from telegram.ext import Application, CommandHandler, ContextTypes, MessageHandler, filters

# ===== –±–∞–∑–æ–≤–∞—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è =====
BASE = Path(__file__).resolve().parent
load_dotenv(BASE / ".env.tg")

BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
CHANNEL = os.getenv("TELEGRAM_TARGET_CHANNEL")

def parse_allowed_ids() -> list[int]:
    ids = []
    raw_multi = os.getenv("TELEGRAM_ALLOWED_USER_IDS", "")
    raw_legacy = os.getenv("TELEGRAM_ALLOWED_USER_ID", "")
    for raw in (raw_multi, raw_legacy):
        for x in raw.replace(";", ",").split(","):
            x = x.strip()
            if x and x.lstrip("-").isdigit():
                ids.append(int(x))
    return list(dict.fromkeys(ids))

ALLOWED_UIDS = parse_allowed_ids()

GREETINGS = {
    87017886: "–ü—Ä–∏–≤–µ—Ç, –ò—Ä–∏–Ω–∞! üëã",
}

def make_header(title: str) -> str:
    """–ï–¥–∏–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∑–∞–≥–æ–ª–æ–≤–∫–æ–≤, —á—Ç–æ–±—ã –Ω–µ –±—ã–ª–æ –æ—à–∏–±–æ–∫ –∫–∞–≤—ã—á–µ–∫."""
    return f"{title} ‚Ä¢ {datetime.now().strftime('%d.%m.%Y %H:%M')}"

def is_allowed(uid: int) -> bool:
    return (uid in ALLOWED_UIDS) if ALLOWED_UIDS else False

def latest(pattern: str):
    files = list(BASE.glob(pattern))
    return max(files, key=lambda p: p.stat().st_mtime) if files else None

def html_file_to_tg_text(p: Path, max_len=4000):
    s = p.read_text(encoding="utf-8")
    s = re.sub(r"<[^>]+>", "", s)
    s = htmllib.unescape(s).strip()
    chunks = []
    while s:
        chunks.append(s[:max_len])
        s = s[max_len:]
    return chunks

def md_file_to_chunks(p: Path, max_len=4000):
    s = p.read_text(encoding="utf-8").strip()
    chunks = []
    while s:
        chunks.append(s[:max_len])
        s = s[max_len:]
    return chunks

# ===== –º–µ–Ω—é =====
def main_menu_kb():
    kb = [[KeyboardButton("üìä –°–∏–≥–Ω–∞–ª")], [KeyboardButton("üìà –ê–Ω–∞–ª–∏–∑")]]
    return ReplyKeyboardMarkup(kb, resize_keyboard=True)

def signal_menu_kb():
    try:
        pool = json.load(open(BASE / "pool.json", "r", encoding="utf-8"))["pool"]
    except Exception:
        pool = ["BTC/USDT", "ETH/USDT", "SOL/USDT", "AVAX/USDT", "APT/USDT", "AAVE/USDT", "LINK/USDT", "TON/USDT", "ARB/USDT"]
    short = [s.split("/")[0] for s in pool]
    rows = [[KeyboardButton("ü§ñ Auto (FULL)")]]
    for i in range(0, len(short), 3):
        rows.append([KeyboardButton(x) for x in short[i:i+3]])
    rows.append([KeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥")])
    return ReplyKeyboardMarkup(rows, resize_keyboard=True)

# ===== handlers =====
async def whoami(update: Update, context: ContextTypes.DEFAULT_TYPE):
    uid = update.effective_user.id if update.effective_user else None
    await update.message.reply_text(f"whoami\n- your id: {uid}\n- allowed: {ALLOWED_UIDS}\n- channel: {CHANNEL}")

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    uid = update.effective_user.id if update.effective_user else 0
    if not is_allowed(uid):
        await update.message.reply_text("–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â—ë–Ω.")
        return
    first = (update.effective_user.first_name or "").strip()
    hello = GREETINGS.get(uid) or (f"–ü—Ä–∏–≤–µ—Ç, {first}!" if first else "–ü—Ä–∏–≤–µ—Ç!")
    await update.message.reply_text(hello)
    await update.message.reply_text("üìã –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", reply_markup=main_menu_kb())

async def handle_back(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("üìã –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", reply_markup=main_menu_kb())

async def handle_signal_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("–í—ã–±–µ—Ä–∏ –∞–∫—Ç–∏–≤ –∏–ª–∏ —Ä–µ–∂–∏–º:", reply_markup=signal_menu_kb())

async def handle_full(update: Update, context: ContextTypes.DEFAULT_TYPE):
    header = make_header("üìù LLM Full –∞–Ω–∞–ª–∏–∑")
    uid = update.effective_user.id if update.effective_user else 0
    if not is_allowed(uid):
        await update.message.reply_text("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞.")
        return
    msg = await update.message.reply_text("–ó–∞–ø—É—Å–∫–∞—é FULL –∞–Ω–∞–ª–∏–∑‚Ä¶ —ç—Ç–æ –∑–∞–π–º—ë—Ç –Ω–µ–º–Ω–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏.")
    proc = subprocess.run(["bash", "-lc", "cd ~/llm-signal && ./signal full"], capture_output=True, text=True, timeout=900)
    analysis = latest("analysis_*.md")
    sig_html = latest("signal_*.html")
    if analysis:
        text = Path(analysis).read_text(encoding="utf-8").split("2Ô∏è‚É£ –°–µ—Ç–∞–ø")[0].strip()
        await context.bot.send_message(chat_id=CHANNEL, text=header + "\n\n" + text)
    if sig_html:
        parts = html_file_to_tg_text(Path(sig_html))
        await context.bot.send_message(chat_id=CHANNEL, text="üì£ –°–∏–≥–Ω–∞–ª\n\n" + parts[0], parse_mode=ParseMode.HTML)

async def handle_analysis(update: Update, context: ContextTypes.DEFAULT_TYPE):
    header = make_header("üìù LLM –ê–Ω–∞–ª–∏–∑")
    uid = update.effective_user.id if update.effective_user else 0
    if not is_allowed(uid):
        await update.message.reply_text("–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â—ë–Ω.")
        return
    msg = await update.message.reply_text("–ó–∞–ø—É—Å–∫–∞—é –∞–Ω–∞–ª–∏–∑ —Ä—ã–Ω–∫–∞‚Ä¶ —ç—Ç–æ –∑–∞–π–º—ë—Ç –Ω–µ–º–Ω–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏.")
    proc = subprocess.run(["bash", "-lc", "cd ~/llm-signal && ./signal full"], capture_output=True, text=True, timeout=900)
    analysis = latest("analysis_*.md")
    if not analysis:
        await msg.edit_text("–ù–µ —É–¥–∞–ª–æ—Å—å —Å—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞—Ç—å –∞–Ω–∞–ª–∏–∑.")
        return
    text = Path(analysis).read_text(encoding="utf-8").split("2Ô∏è‚É£ –°–µ—Ç–∞–ø")[0].strip()
    await context.bot.send_message(chat_id=CHANNEL, text=header + "\n" + text)
    safe_tail = htmllib.escape("\n".join(proc.stdout.splitlines()[-20:]) or "(–ª–æ–≥ –ø—É—Å—Ç)")
    await msg.edit_text(f"–ì–æ—Ç–æ–≤–æ\n<pre>{safe_tail}</pre>", parse_mode=ParseMode.HTML)

# ===== main =====
def register_text_handlers(app: Application):
    app.add_handler(MessageHandler(filters.TEXT & filters.Regex("^üìä –°–∏–≥–Ω–∞–ª$"), handle_signal_menu))
    app.add_handler(MessageHandler(filters.TEXT & filters.Regex("^üìà –ê–Ω–∞–ª–∏–∑$"), handle_analysis))
    app.add_handler(MessageHandler(filters.TEXT & filters.Regex("^ü§ñ Auto \\(FULL\\)$"), handle_full))
    app.add_handler(MessageHandler(filters.TEXT & filters.Regex("^‚¨ÖÔ∏è –ù–∞–∑–∞–¥$"), handle_back))

def main():
    if not BOT_TOKEN or not CHANNEL:
        raise SystemExit("Set TELEGRAM_BOT_TOKEN and TELEGRAM_TARGET_CHANNEL in .env.tg")
    app = Application.builder().token(BOT_TOKEN).build()
    app.add_handler(CommandHandler("whoami", whoami))
    app.add_handler(CommandHandler("start", start))
    register_text_handlers(app)
    app.run_polling(allowed_updates=Update.ALL_TYPES)

if __name__ == "__main__":
    main()


