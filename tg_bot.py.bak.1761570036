#!/usr/bin/env python3
import os, time, subprocess, re, html as htmllib, json
from datetime import datetime
from pathlib import Path
from dotenv import load_dotenv
from telegram import Update, KeyboardButton, ReplyKeyboardMarkup
from telegram.constants import ParseMode
from telegram.ext import Application, CommandHandler, ContextTypes, MessageHandler, filters

# ===== –±–∞–∑–æ–≤–∞—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è =====
BASE = Path(__file__).resolve().parent
load_dotenv(BASE / ".env.tg")

BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
CHANNEL = os.getenv("TELEGRAM_TARGET_CHANNEL")

def parse_allowed_ids() -> list[int]:
    ids = []
    raw_multi = os.getenv("TELEGRAM_ALLOWED_USER_IDS", "")
    raw_legacy = os.getenv("TELEGRAM_ALLOWED_USER_ID", "")
    for raw in (raw_multi, raw_legacy):
        for x in raw.replace(";", ",").split(","):
            x = x.strip()
            if x and x.lstrip("-").isdigit():
                ids.append(int(x))
    return list(dict.fromkeys(ids))

ALLOWED_UIDS = parse_allowed_ids()


# ===== —Å–ø–∏—Å–æ–∫ —Ç–∏–∫–µ—Ä–æ–≤ –¥–ª—è single =====
try:
    _pool = json.load(open(BASE/"pool.json","r",encoding="utf-8"))["pool"]
    SYMBOLS = [s.split("/")[0] for s in _pool]
except Exception:
    SYMBOLS = ["BTC","ETH","SOL","AVAX","APT","AAVE","LINK","TON","ARB"]
SYMBOLS_SET = set(SYMBOLS)

GREETINGS = {
    87017886: "–ü—Ä–∏–≤–µ—Ç, –ò—Ä–∏–Ω–∞! üëã",
}

def make_header(title: str) -> str:
    """–ï–¥–∏–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∑–∞–≥–æ–ª–æ–≤–∫–æ–≤, —á—Ç–æ–±—ã –Ω–µ –±—ã–ª–æ –æ—à–∏–±–æ–∫ –∫–∞–≤—ã—á–µ–∫."""
    return f"{title} ‚Ä¢ {datetime.now().strftime('%d.%m.%Y %H:%M')}"

def is_allowed(uid: int) -> bool:
    return (uid in ALLOWED_UIDS) if ALLOWED_UIDS else False

def latest(pattern: str):
    files = list(BASE.glob(pattern))
    return max(files, key=lambda p: p.stat().st_mtime) if files else None

def html_file_to_tg_text(p: Path, max_len=4000):
    s = p.read_text(encoding="utf-8")
    s = re.sub(r"<[^>]+>", "", s)
    s = htmllib.unescape(s).strip()
    chunks = []
    while s:
        chunks.append(s[:max_len])
        s = s[max_len:]
    return chunks

def md_file_to_chunks(p: Path, max_len=4000):
    s = p.read_text(encoding="utf-8").strip()
    chunks = []
    while s:
        chunks.append(s[:max_len])
        s = s[max_len:]
    return chunks

# ===== –º–µ–Ω—é =====
def main_menu_kb():
    kb = [[KeyboardButton("üìä –°–∏–≥–Ω–∞–ª")], [KeyboardButton("üìà –ê–Ω–∞–ª–∏–∑")]]
    return ReplyKeyboardMarkup(kb, resize_keyboard=True)

def signal_menu_kb():
    try:
        pool = json.load(open(BASE / "pool.json", "r", encoding="utf-8"))["pool"]
    except Exception:
        pool = ["BTC/USDT", "ETH/USDT", "SOL/USDT", "AVAX/USDT", "APT/USDT", "AAVE/USDT", "LINK/USDT", "TON/USDT", "ARB/USDT"]
    short = [s.split("/")[0] for s in pool]
    rows = [[KeyboardButton("ü§ñ Auto (FULL)")]]
    for i in range(0, len(short), 3):
        rows.append([KeyboardButton(x) for x in short[i:i+3]])
    rows.append([KeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥")])
    return ReplyKeyboardMarkup(rows, resize_keyboard=True)

# ===== handlers =====
async def whoami(update: Update, context: ContextTypes.DEFAULT_TYPE):
    uid = update.effective_user.id if update.effective_user else None
    await update.message.reply_text(f"whoami\n- your id: {uid}\n- allowed: {ALLOWED_UIDS}\n- channel: {CHANNEL}")

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    uid = update.effective_user.id if update.effective_user else 0
    if not is_allowed(uid):
        await update.message.reply_text("–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â—ë–Ω.")
        return
    first = (update.effective_user.first_name or "").strip()
    hello = GREETINGS.get(uid) or (f"–ü—Ä–∏–≤–µ—Ç, {first}!" if first else "–ü—Ä–∏–≤–µ—Ç!")
    await update.message.reply_text(hello)
    await update.message.reply_text("üìã –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", reply_markup=main_menu_kb())

async def handle_back(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("üìã –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", reply_markup=main_menu_kb())

async def handle_signal_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("–í—ã–±–µ—Ä–∏ –∞–∫—Ç–∏–≤ –∏–ª–∏ —Ä–µ–∂–∏–º:", reply_markup=signal_menu_kb())

async def handle_full(update: Update, context: ContextTypes.DEFAULT_TYPE):
    header = make_header("üìù LLM Full –∞–Ω–∞–ª–∏–∑")
    uid = update.effective_user.id if update.effective_user else 0
    if not is_allowed(uid):
        await update.message.reply_text("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞.")
        return
    msg = await update.message.reply_text("–ó–∞–ø—É—Å–∫–∞—é FULL –∞–Ω–∞–ª–∏–∑‚Ä¶ —ç—Ç–æ –∑–∞–π–º—ë—Ç –Ω–µ–º–Ω–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏.")
    proc = subprocess.run(["bash", "-lc", "cd ~/llm-signal && ./signal full"], capture_output=True, text=True, timeout=900)
    analysis = latest("analysis_*.md")
    sig_html = latest("signal_*.html")
    if analysis:
        text = Path(analysis).read_text(encoding="utf-8").split("2Ô∏è‚É£ –°–µ—Ç–∞–ø")[0].strip()
        await context.bot.send_message(chat_id=CHANNEL, text=header + "\n\n" + text)
    if sig_html:
        parts = html_file_to_tg_text(Path(sig_html))
        await context.bot.send_message(chat_id=CHANNEL, text="üì£ –°–∏–≥–Ω–∞–ª\n\n" + parts[0])

async def handle_analysis(update: Update, context: ContextTypes.DEFAULT_TYPE):
    header = make_header("üìù LLM –ê–Ω–∞–ª–∏–∑")
    uid = update.effective_user.id if update.effective_user else 0
    if not is_allowed(uid):
        await update.message.reply_text("–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â—ë–Ω.")
        return
    msg = await update.message.reply_text("–ó–∞–ø—É—Å–∫–∞—é –∞–Ω–∞–ª–∏–∑ —Ä—ã–Ω–∫–∞‚Ä¶ —ç—Ç–æ –∑–∞–π–º—ë—Ç –Ω–µ–º–Ω–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏.")
    proc = subprocess.run(["bash", "-lc", "cd ~/llm-signal && ./signal full"], capture_output=True, text=True, timeout=900)
    analysis = latest("analysis_*.md")
    if not analysis:
        await msg.edit_text("–ù–µ —É–¥–∞–ª–æ—Å—å —Å—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞—Ç—å –∞–Ω–∞–ª–∏–∑.")
        return
    text = Path(analysis).read_text(encoding="utf-8").split("2Ô∏è‚É£ –°–µ—Ç–∞–ø")[0].strip()
    await context.bot.send_message(chat_id=CHANNEL, text=header + "\n" + text)
    safe_tail = htmllib.escape("\n".join(proc.stdout.splitlines()[-20:]) or "(–ª–æ–≥ –ø—É—Å—Ç)")
    await msg.edit_text(f"–ì–æ—Ç–æ–≤–æ\n<pre>{safe_tail}</pre>", parse_mode=ParseMode.HTML)

# ===== main =====

async def handle_symbol(update: Update, context: ContextTypes.DEFAULT_TYPE):
    uid = update.effective_user.id if update.effective_user else 0
    if not is_allowed(uid):
        await update.message.reply_text("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞.")
        return

    sym_text = (update.message.text or "").strip().upper()
    if sym_text not in SYMBOLS_SET:
        await update.message.reply_text("–ù–µ —Ä–∞—Å–ø–æ–∑–Ω–∞–ª —Å–∏–º–≤–æ–ª. –í—ã–±–µ—Ä–∏ –∏–∑ –º–µ–Ω—é.")
        return
    symbol = f"{sym_text}/USDT"

    msg = await update.message.reply_text(f"–ì–æ—Ç–æ–≤–ª—é —Å–∏–≥–Ω–∞–ª –ø–æ {symbol}‚Ä¶")

    import subprocess, json, html as _html
    proc = subprocess.run(
        ["bash","-lc", f"cd ~/llm-signal && ./signal --symbol '{symbol}'"],
        capture_output=True, text=True, timeout=600
    )

    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø–æ–ª–Ω—ã–π —Å–∏–≥–Ω–∞–ª –≤ –∫–∞–Ω–∞–ª
    sig_html = latest("signal_*.html")
    if sig_html:
        parts = html_file_to_tg_text(sig_html)
        parts[0] = "üì£ –°–∏–≥–Ω–∞–ª\n\n" + parts[0]
        await context.bot.send_message(chat_id=CHANNEL, text=parts[0])
        for chunk in parts[1:]:
            await context.bot.send_message(chat_id=CHANNEL, text=chunk)

    # –ú–∏–Ω–∏-–±–ª–æ–∫ —Å –¥–∏–∞–ø–∞–∑–æ–Ω–æ–º –≤—Ö–æ–¥–∞ / —Ä–µ–∂–∏–º–æ–º / —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å—é / –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ–º
    try:
        last_raw = latest("logs/last.raw.json")
        if last_raw:
            data = json.loads(Path(last_raw).read_text(encoding="utf-8"))
            if isinstance(data, dict):
                sym = data.get("symbol") or symbol
                er = (data.get("entry_range") or {})
                er_min = er.get("min") if er.get("min") is not None else "‚Äî"
                er_max = er.get("max") if er.get("max") is not None else "‚Äî"
                entry_mode = (data.get("entry_mode") or "limit")
                confidence = (data.get("confidence") or "Medium")
                confirm = data.get("confirmation_rules") or data.get("break_even_rule") or ""
                confirm = (confirm or "‚Äî").strip()
                mini = (
                    "üìä " + str(sym) + "\n"
                    "üéØ " + str(er_min) + "‚Äì" + str(er_max) + "  |  " + entry_mode + "  |  " + confidence + "\n"
                    "‚òë " + confirm
                )
                await context.bot.send_message(chat_id=CHANNEL, text=mini)
    except Exception:
        pass

    # –•–≤–æ—Å—Ç –ª–æ–≥–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
    tail = "\n".join((proc.stdout or "").strip().splitlines()[-20:])
    await msg.edit_text("–ì–æ—Ç–æ–≤–æ\n<pre>" + _html.escape(tail or "(–ª–æ–≥ –ø—É—Å—Ç)") + "</pre>", parse_mode=ParseMode.HTML)


def register_text_handlers(app: Application):
    app.add_handler(MessageHandler(filters.TEXT & filters.Regex("^üìä –°–∏–≥–Ω–∞–ª$"), handle_signal_menu))
    app.add_handler(MessageHandler(filters.TEXT & filters.Regex("^üìà –ê–Ω–∞–ª–∏–∑$"), handle_analysis))
    app.add_handler(MessageHandler(filters.TEXT & filters.Regex("^ü§ñ Auto \\(FULL\\)$"), handle_full))
    app.add_handler(MessageHandler(filters.TEXT & filters.Regex("^‚¨ÖÔ∏è –ù–∞–∑–∞–¥$"), handle_back))
    sym_regex = "^(" + "|".join(sorted(SYMBOLS_SET)) + ")$"
    app.add_handler(MessageHandler(filters.TEXT & filters.Regex(sym_regex), handle_symbol))

def main():
    if not BOT_TOKEN or not CHANNEL:
        raise SystemExit("Set TELEGRAM_BOT_TOKEN and TELEGRAM_TARGET_CHANNEL in .env.tg")
    app = Application.builder().token(BOT_TOKEN).build()
    app.add_handler(CommandHandler("whoami", whoami))
    app.add_handler(CommandHandler("start", start))
    register_text_handlers(app)
    app.run_polling(allowed_updates=Update.ALL_TYPES)

if __name__ == "__main__":
    main()


